[["index.html", "MA 5124 Financial Time Series Analysis &amp; Forecasting Course Syllabus Pre-requiites Learning Objectives Learning Outcomes Outline Syllabus Method of Assessment Lecturer Schedule Copyright Notice", " MA 5124 Financial Time Series Analysis &amp; Forecasting Dr. Priyanga D. Talagala 2021-02-20 Course Syllabus Module Code: MA 5124 Title: Financial Time Series Analysis &amp; Forecasting Credits: 4 Pre-requiites None Learning Objectives The purpose of this course is to provide students with introductory tools for the time series analysis of financial time series. Analyze of data series based on stochastic and non stochastic models Learning Outcomes On successful completion of this course, students will be able to provide more than an introductory treatment of the topics. Students are encouraged to pursue further study in this area if they find that the topics covered in this course. Outline Syllabus Definition and examples of time series back-shift and differencing-operators, - strong and weak stationarity, definition of ACF, PACF. Definitions and properties of the \\(MA(q), MA(\\infty), AR(p), AR(\\infty)\\) and \\(ARMA(p,q)\\),in particualr their acf’s causal stationarity of AR invertibility of MA models and causal stationarity and invertibility of ARMA; - concept of spectral density function and its applications definition and properties of integrated \\(ARIMA(p,d,q)\\) processes definition and properties of random walks with or without drift. Model selection following the AIC and BIC brief introduction to linear prediction and calculation of forecasting intervals for normal ARMA models point and interval forecasts for normal random walks with or without drift. Definition and properties of the VAR (vector autoregressive) model, arrange a univariate time series as a multivariate Markov model. Nonlinear properties of financial time series definition and properties of the well known ARCH, GARCH etc. Cointegration in Single Equations, Modeling and Forecasting Financial Time Series. Method of Assessment Assignment 30% End-semester examination 70% Lecturer Dr. Priyanga D. Talagala Schedule Lectures: Sunday [9.00am -12.00 noon] Copyright Notice My lectures and course materials, including presentations, tests, exams, outlines, and similar materials, are protected by copyright. I am the exclusive owner of copyright in those materials I create. I encourage you to take notes and make copies of course materials for your own educational use. However, you may not, nor may you knowingly allow others to reproduce or distribute lecture notes and course materials publicly without my express written consent. "],["intro.html", "Chapter 1 Intordution to Time Series Forecasting", " Chapter 1 Intordution to Time Series Forecasting "],["arima-models.html", "Chapter 2 ARIMA models 2.1 Stationarity and differencing 2.2 Non-seasonal ARIMA models 2.3 Estimation and order selection 2.4 Seasonal ARIMA models 2.5 Theoretical properties of the models 2.6 Unit root tests 2.7 ARIMA modelling in R 2.8 Forecasting 2.9 References:", " Chapter 2 ARIMA models AR: autoregressive (lagged observations as inputs) I: integrated (differencing to make series stationary) MA: moving average (lagged errors as inputs) An ARIMA model is rarely interpretable in terms of visible data structures like trend and seasonality. But it can capture a huge range of time series patterns. 2.1 Stationarity and differencing 2.1.1 Stationarity Definition If \\(\\{y_t\\}\\) is a stationary time series, then for all \\(s\\), the distribution of \\((y_t,\\dots,y_{t+s})\\) does not depend on \\(t\\). A stationary series is: roughly horizontal constant variance no patterns predictable in the long-term Transformations help to stabilize the variance. For ARIMA modelling, we also need to stabilize the mean. Identifying non-stationary series time plot. The ACF of stationary data drops to zero relatively quickly The ACF of non-stationary data decreases slowly. For non-stationary data, the value of r1 is often large and positive. A time series, \\(\\{Y_t, t=0, \\pm1,\\dots\\}\\) is said to be strict stationary, if \\((Y_1, \\dots, Y_n)\\) and \\((Y_{1+h}, \\dots, Y_{n+h})\\) have the same joint distribution for all integers \\(h\\) and \\(n&gt;0.\\) 2.1.1.1 Weak Stationarity Definition: Covariance function (in (Brockwell et al. 2016), p. 15; the notations have been changed for consistency within this note) Let \\(\\{Y_t\\}\\) be a time series with \\(E(Y_t^2)&lt;\\infty.\\) The mean function of \\(\\{Y_t\\}\\) is \\[\\mu_Y(t)= E(Y_t)\\] The covariance function of \\(\\{Y_t\\}\\) is \\[\\gamma_Y(r,s)=Cov(Y_r, Y_s)=E[(Y_r-\\mu_Y(r))(Y_s-\\mu_Y(s))]\\] for all integers \\(r\\) and \\(s\\). Definition: Weakly stationary (in (Brockwell et al. 2016), p. 15; the notations have been changed for consistency within this note) \\(\\{Y_t\\}\\) is weakly stationary if \\(\\mu_Y(t)\\) is independent of \\(t\\), and \\(\\gamma_Y(t+h,t)\\) is independent of \\(t\\) for each \\(h\\). Unless specifically indicate otherwise, whenever we use the term stationary we shall mean weakly stationary. 2.1.2 Differencing Differencing helps to stabilize the mean. The differenced series is the change between each observation in the original series: \\(y&#39;_t = y_t - y_{t-1}\\). The differenced series will have only \\(T-1\\) values since it is not possible to calculate a difference \\(y_1&#39;\\) for the first observation. 2.1.2.1 Second-order differencing Occasionally the differenced data will not appear stationary and it may be necessary to difference the data a second time: \\[y&#39;&#39;_{t} = y&#39;_{t} - y&#39;_{t - 1}\\] \\[= (y_t - y_{t-1}) - (y_{t-1}-y_{t-2})\\] \\[= y_t - 2y_{t-1} +y_{t-2}.\\] \\(y_t&#39;&#39;\\) will have \\(T-2\\) values. In practice, it is almost never necessary to go beyond second-order differences. 2.1.2.2 Seasonal differencing A seasonal difference is the difference between an observation and the corresponding observation from the previous year. \\[y&#39;_t = y_t - y_{t-m}\\] where \\(m=\\) number of seasons. For monthly data \\(m=12\\). For quarterly data \\(m=4\\). Example : Electricity production usmelec %&gt;% autoplot(Generation) usmelec %&gt;% autoplot(log(Generation)) usmelec %&gt;% autoplot(log(Generation) %&gt;% difference(12)) usmelec %&gt;% autoplot(log(Generation) %&gt;% difference(12) %&gt;% difference()) Seasonally differenced series is closer to being stationary. Remaining non-stationarity can be removed with further first difference. If \\(y&#39;_t = y_t - y_{t-12}\\) denotes seasonally differenced series, then twice-differenced series is \\[y^*_t = y&#39;_t - y&#39;_{t-1}\\] \\[= (y_t - y_{t-12}) - (y_{t-1} - y_{t-13})\\] \\[= y_t - y_{t-1} - y_{t-12} + y_{t-13}.\\] When both seasonal and first differences are applied \\(\\dots\\) it makes no difference which is done first—the result will be the same. If seasonality is strong, we recommend that seasonal differencing be done first because sometimes the resulting series will be stationary and there will be no need for further first difference. It is important that if differencing is used, the differences are interpretable. 2.1.2.3 Interpretation of differencing first differences are the change between one observation and the next; seasonal differences are the change between one year to the next. But taking lag 3 differences for yearly data, for example, results in a model which cannot be sensibly interpreted. 2.1.3 Backshift notation A very useful notational device is the backward shift operator, \\(B\\), which is used as follows: \\[B y_{t} = y_{t - 1}\\] In other words, \\(B\\), operating on \\(y_{t}\\), has the effect of shifting the data back one period. Two applications of \\(B\\) to \\(y_{t}\\) shifts the data back two periods: \\[B(By_{t}) = B^{2}y_{t} = y_{t-2}\\] For monthly data, if we wish to shift attention to “the same month last year”, then \\(B^{12}\\) is used, and the notation is \\[B^{12}y_{t} = y_{t-12}\\]. The backward shift operator is convenient for describing the process of differencing. A first difference can be written as \\[y^{\\prime}_{t}= y_{t} - y_{t-1}= y_t - By_{t} = (1 - B)y_{t}\\] Note that a first difference is represented by \\((1 - B)\\). Similarly, if second-order differences (i.e., first differences of first differences) have to be computed, then: \\[y&#39;&#39;_{t} = y_{t} - 2y_{t - 1} + y_{t - 2} = (1 - B)^{2} y_{t}\\] Second-order difference is denoted \\((1- B)^{2}\\). Second-order difference is not the same as a second difference, which would be denoted \\(1- B^{2}\\); In general, a \\(d\\)th-order difference can be written as \\[(1 - B)^{d} y_{t}\\] * A seasonal difference followed by a first difference can be written as \\[(1-B)(1-B^m)y_t\\] - The “backshift” notation is convenient because the terms can be multiplied together to see the combined effect. \\[(1-B)(1-B^m)y_t = (1 - B - B^m + B^{m+1})y_t\\] \\[= y_t-y_{t-1}-y_{t-m}+y_{t-m-1}.\\] - For monthly data, \\(m=12\\) and we obtain the same result as earlier. 2.2 Non-seasonal ARIMA models 2.2.1 Autoregressive models Autoregressive (AR) models: \\[y_{t} = c + \\phi_{1}y_{t - 1} + \\phi_{2}y_{t - 2} + \\cdots + \\phi_{p}y_{t - p} + \\varepsilon_{t},\\] where \\(\\varepsilon_t\\) is white noise. This is a multiple regression with of \\(y_t\\) as predictors. 2.2.1.1 AR(1) model \\[y_{t} = 18 -0.8 y_{t - 1} + \\varepsilon_{t}\\] \\[\\varepsilon_t\\sim N(0,1),\\quad T=100.\\] \\[y_{t} = c + \\phi_1 y_{t - 1} + \\varepsilon_{t}\\] When \\(\\phi_1=0\\), \\(y_t\\) is equivalent to WN When \\(\\phi_1=1\\) and \\(c=0\\), \\(y_t\\) is equivalent to a RW When \\(\\phi_1=1\\) and \\(c\\ne0\\), \\(y_t\\) is equivalent to a RW with drift When \\(\\phi_1&lt;0\\), \\(y_t\\) tends to oscillate between positive and negative values. 2.2.1.2 AR(2) model \\[y_t = 8 + 1.3y_{t-1} - 0.7 y_{t-2} + \\varepsilon_t\\] \\[\\varepsilon_t\\sim N(0,1), \\qquad T=100.\\] 2.2.1.3 Stationarity conditions We normally restrict autoregressive models to stationary data, and then some constraints on the values of the parameters are required. General condition for stationarity Complex roots of \\(1-\\phi_1 z - \\phi_2 z^2 - \\dots - \\phi_pz^p\\) lie outside the unit circle on the complex plane. For \\(p=1\\): \\(-1&lt;\\phi_1&lt;1\\). For \\(p=2\\):\\(-1&lt;\\phi_2&lt;1\\qquad \\phi_2+\\phi_1 &lt; 1 \\qquad \\phi_2 -\\phi_1 &lt; 1\\). More complicated conditions hold for \\(p\\ge3\\). Estimation software takes care of this. 2.2.2 Moving Average (MA) models Moving Average (MA) models: \\[y_{t} = c + \\varepsilon_t + \\theta_{1}\\varepsilon_{t - 1} + \\theta_{2}\\varepsilon_{t - 2} + \\cdots + \\theta_{q}\\varepsilon_{t - q},\\] where \\(\\varepsilon_t\\) is white noise. This is a multiple regression with past errors as predictors. Don’t confuse this with moving average smoothing! 2.2.2.1 MA(1) model \\[y_t = 20 + \\varepsilon_t + 0.8 \\varepsilon_{t-1}\\] \\[\\varepsilon_t\\sim N(0,1),\\quad T=100.\\] 2.2.2.2 MA(2) model \\[y_t = \\varepsilon_t -\\varepsilon_{t-1} + 0.8 \\varepsilon_{t-2}\\] \\[\\varepsilon_t\\sim N(0,1),\\quad T=100.\\] 2.2.2.3 MA(\\(\\infty\\)) models It is possible to write any stationary AR(\\(p\\)) process as an MA(\\(\\infty\\)) process. Example: AR(1) \\[y_t = \\phi_1y_{t-1} + \\varepsilon_t\\] \\[= \\phi_1(\\phi_1y_{t-2} + \\varepsilon_{t-1}) + \\varepsilon_t\\] \\[= \\phi_1^2y_{t-2} + \\phi_1 \\varepsilon_{t-1} + \\varepsilon_t\\] \\[= \\phi_1^3y_{t-3} + \\phi_1^2\\varepsilon_{t-2} + \\phi_1 \\varepsilon_{t-1} + \\varepsilon_t\\] \\[\\dots\\] Provided \\(-1 &lt; \\phi_1 &lt; 1\\): \\[y_t = \\varepsilon_t + \\phi_1 \\varepsilon_{t-1} + \\phi_1^2 \\varepsilon_{t-2} + \\phi_1^3 \\varepsilon_{t-3} + \\cdots\\] 2.2.3 Invertibility Any MA(\\(q\\)) process can be written as an AR(\\(\\infty\\)) process if we impose some constraints on the MA parameters. Then the MA model is called “invertible”. Invertible models have some mathematical properties that make them easier to use in practice. Invertibility of an ARIMA model is equivalent to forecastability of an ETS model. General condition for invertibility Complex roots of \\(1+\\theta_1 z + \\theta_2 z^2 + \\dots + \\theta_qz^q\\) lie outside the unit circle on the complex plane. For \\(q=1\\): \\(-1&lt;\\theta_1&lt;1\\). For \\(q=2\\):\\(-1&lt;\\theta_2&lt;1\\qquad \\theta_2+\\theta_1 &gt;-1 \\qquad \\theta_1 -\\theta_2 &lt; 1\\). More complicated conditions hold for \\(q\\ge3\\). Estimation software takes care of this. 2.2.4 ARIMA models Autoregressive Moving Average models: \\[y_{t} = c + \\phi_{1}y_{t - 1} + \\cdots + \\phi_{p}y_{t - p}\\] \\[+ \\theta_{1}\\varepsilon_{t - 1} + \\cdots + \\theta_{q}\\varepsilon_{t - q} + \\varepsilon_{t}\\] Predictors include both lagged values of \\(y_t\\) and lagged errors. Conditions on coefficients ensure stationarity. Conditions on coefficients ensure invertibility. Autoregressive Integrated Moving Average models Combine ARMA model with differencing. \\((1-B)^d y_t\\) follows an ARMA model. Autoregressive Integrated Moving Average models ARIMA(\\(p, d, q\\)) model AR: \\(p =\\) order of the autoregressive part I: \\(d =\\) degree of first differencing involved MA: \\(q =\\) order of the moving average part. White noise model: ARIMA(0,0,0) Random walk: ARIMA(0,1,0) with no constant Random walk with drift: ARIMA(0,1,0) with const. AR(\\(p\\)): ARIMA(\\(p\\),0,0) MA(\\(q\\)): ARIMA(0,0,\\(q\\)) 2.2.5 Backshift notation for ARIMA ARMA model: \\[y_{t} = c + \\phi_{1}By_{t} + \\cdots + \\phi_pB^py_{t} + \\varepsilon_{t} + \\theta_{1}B\\varepsilon_{t} + \\cdots + \\theta_qB^q\\varepsilon_{t}\\] \\[\\text{or}\\quad (1-\\phi_1B - \\cdots - \\phi_p B^p) y_t = c + (1 + \\theta_1 B + \\cdots + \\theta_q B^q)\\varepsilon_t\\] ARIMA(1,1,1) model: \\[(1 - \\phi_{1} B) (1 - B) y_{t} = c + (1 + \\theta_{1} B) \\varepsilon_{t}\\] NOTE: Written out: \\[y_t = c + y_{t-1} + \\phi_1 y_{t-1}- \\phi_1 y_{t-2} + \\theta_1\\varepsilon_{t-1} + \\varepsilon_t\\] 2.3 Estimation and order selection 2.3.1 Maximum likelihood estimation Having identified the model order, we need to estimate the parameters \\(c\\), \\(\\phi_1,\\dots,\\phi_p\\), \\(\\theta_1,\\dots,\\theta_q\\). MLE is very similar to least squares estimation obtained by minimizing \\[\\sum_{t-1}^T e_t^2\\] The ARIMA() function allows CLS or MLE estimation. Non-linear optimization must be used in either case. Different software will give different estimates. 2.3.2 Partial autocorrelations Partial autocorrelations measure relationship between \\(y_{t}\\) and \\(y_{t - k}\\), when the effects of other time lags — \\(1, 2, 3, \\dots, k - 1\\) — are removed. \\[\\alpha_k = k \\text{th partial autocorrelation coefficient}\\] \\[= \\text{equal to the estimate of } \\phi_k \\text{ in regression:}\\] \\[y_t = c + \\phi_1 y_{t-1} + \\phi_2 y_{t-2} + \\dots + \\phi_k y_{t-k}.\\] Varying number of terms on RHS gives \\(\\alpha_k\\) for different values of \\(k\\). \\(\\alpha_1=\\rho_1\\) same critical values of \\(\\pm 1.96/\\sqrt{T}\\) as for ACF. Last significant \\(\\alpha_k\\) indicates the order of an AR model. 2.3.2.1 Example: Mink trapping mink %&gt;% gg_tsdisplay(value, plot_type=&#39;partial&#39;) 2.3.3 ACF and PACF interpretation AR(1) \\[\\rho_k = \\phi_1^k\\qquad\\text{for } k=1,2,\\dots;\\] \\[\\alpha_1 = \\phi_1 \\qquad\\alpha_k = 0\\qquad\\text{for } k=2,3,\\dots.\\] So we have an AR(1) model when autocorrelations exponentially decay there is a single significant partial autocorrelation. AR(\\(p\\)) ACF dies out in an exponential or damped sine-wave manner PACF has all zero spikes beyond the \\(p\\)th spike So we have an AR(\\(p\\)) model when the ACF is exponentially decaying or sinusoidal there is a significant spike at lag \\(p\\) in PACF, but none beyond \\(p\\) MA(1) \\[\\rho_1 = \\theta_1\\qquad \\rho_k = 0\\qquad\\text{for }k=2,3,\\dots;\\] \\[\\alpha_k = -(-\\theta_1)^k\\] So we have an MA(1) model when the PACF is exponentially decaying and there is a single significant spike in ACF MA(\\(q\\)) PACF dies out in an exponential or damped sine-wave manner ACF has all zero spikes beyond the \\(q\\)th spike So we have an MA(\\(q\\)) model when the PACF is exponentially decaying or sinusoidal there is a significant spike at lag \\(q\\) in ACF, but none beyond \\(q\\) 2.3.4 Information criteria Akaike’s Information Criterion (AIC) \\[\\text{AIC} = -2 \\log(L) + 2(p+q+k+1),\\] where \\(L\\) is the likelihood of the data, \\(k=1\\) if \\(c\\ne0\\) and \\(k=0\\) if \\(c=0\\). Corrected AIC: \\[\\text{AICc} = \\text{AIC} + \\displaystyle\\frac{2(p+q+k+1)(p+q+k+2)}{T-p-q-k-2}.\\] Bayesian Information Criterion: \\[\\text{BIC} = \\text{AIC} + [\\log(T)-2](p+q+k+1).\\] Good models are obtained by minimizing either the AIC, AICc or BIC. Our preference is to use the AICc. 2.4 Seasonal ARIMA models ARIMA \\(~\\underbrace{(p, d, q)}\\) \\(\\underbrace{(P, D, Q)_{m}}\\) \\({\\uparrow}\\) \\({\\uparrow}\\) Non-seasonal part Seasonal part of of the model of the model where \\(m =\\) number of observations per year. Example: ARIMA\\((1, 1, 1)(1, 1, 1)_{4}\\) model (without constant) \\[(1 - \\phi_{1}B)(1 - \\Phi_{1}B^{4}) (1 - B) (1 - B^{4})y_{t} ~= ~ (1 + \\theta_{1}B) (1 + \\Theta_{1}B^{4})\\varepsilon_{t}. \\] All the factors can be multiplied out and the general model written as follows: \\[y_{t} = (1 + \\phi_{1})y_{t - 1} - \\phi_1y_{t-2} + (1 + \\Phi_{1})y_{t - 4}- (1 + \\phi_{1} + \\Phi_{1} + \\phi_{1}\\Phi_{1})y_{t - 5} + (\\phi_{1} + \\phi_{1} \\Phi_{1}) y_{t - 6}\\] \\[- \\Phi_{1} y_{t - 8} + (\\Phi_{1} + \\phi_{1} \\Phi_{1}) y_{t - 9} - \\phi_{1} \\Phi_{1} y_{t - 10} + \\varepsilon_{t} + \\theta_{1}\\varepsilon_{t - 1} + \\Theta_{1}\\varepsilon_{t - 4} + \\theta_{1}\\Theta_{1}\\varepsilon_{t - 5}.\\] 2.4.1 Common ARIMA models The US Census Bureau uses the following models most often: 2.4.2 Seasonal ARIMA models The seasonal part of an AR or MA model will be seen in the seasonal lags of the PACF and ACF. ARIMA(0,0,0)(0,0,1)\\(_{12}\\) will show: a spike at lag 12 in the ACF but no other significant spikes. The PACF will show exponential decay in the seasonal lags; that is, at lags 12, 24, 36, . ARIMA(0,0,0)(1,0,0)\\(_{12}\\) will show: exponential decay in the seasonal lags of the ACF a single significant spike at lag 12 in the PACF. 2.5 Theoretical properties of the models 2.5.1 Autoregressive (AR) models 2.5.1.1 Properties of AR(1) model Consider the following \\(AR(1)\\) model. \\[\\begin{equation} \\label{eq:ar} Y_t=\\phi_0+\\phi_1Y_{t-1}+\\epsilon_{t} \\end{equation}\\] where \\(\\varepsilon_t\\) is white noise. 2.5.1.1.1 Mean Assuming that the series is weak stationary, we have \\(E(Y_t)=\\mu\\), \\(Var(Y_t)=\\gamma_0\\), and \\(Cov(Y_t, Y_{t-k})=\\gamma_k\\), where \\(\\mu\\) and \\(\\gamma_0\\) are constants. Given that \\({\\epsilon_t}\\) is a white noise, we have \\(E(\\epsilon_t)=0\\). The mean of \\(AR(1)\\) process can be computed as follows: \\[ \\begin{aligned} E(Y_t) &amp;= E(\\phi_0+\\phi_1 Y_{t-1}) \\\\ &amp;= E(\\phi_0) +E(\\phi_1 Y_{t-1}) \\\\ &amp;= \\phi_0 +\\phi_1 E(Y_{t-1}). \\\\ \\end{aligned} \\] Under the stationarity condition, \\(E(Y_t)=E(Y_{t-1})=\\mu\\). Thus we get \\[\\mu = \\phi_0+\\phi_1\\mu.\\] Solving for \\(\\mu\\) yields \\[\\begin{equation} \\label{eq:2} E(Y_t)=\\mu=\\frac{\\phi_0}{1-\\phi_1}. \\end{equation}\\] The results has two constraints for \\(Y_t\\). First, the mean of \\(Y_t\\) exists if \\(\\phi_1 \\neq 1 .\\) The mean of \\(Y_t\\) is zero if and only if \\(\\phi_0=0\\). 2.5.1.1.2 Variance and the stationary condition of AR (1) process First take variance of both sides of Equation (??) \\[Var(Y_t)=Var(\\phi_0+\\phi_1 Y_{t-1}+\\epsilon_t)\\] The \\(Y_{t-1}\\) occurred before time \\(t\\). The \\(\\epsilon_t\\) does not depend on any past observation. Hence, \\(cov(Y_{t-1}, \\epsilon_t)= 0\\). Furthermore, \\({\\epsilon_t}\\) is a white noise. This gives \\[Var(Y_t)=\\phi_1^2 Var(Y_{t-1})+\\sigma^2.\\] Under the stationarity condition, \\(Var(Y_t)=Var(Y_{t-1})\\). Hence, \\[Var(Y_t)=\\frac{\\sigma^2}{1-\\phi_1^2}.\\] provided that \\(\\phi_1^2 &lt; 1\\) or \\(|\\phi_1| &lt; 1\\) (The variance of a random variable is bounded and non-negative). The necessary and sufficient condition for the \\(AR(1)\\) model in Equation (??) to be weakly stationary is \\(|\\phi_1| &lt; 1\\). This condition is equivalent to saying that the root of \\(1-\\phi_1B = 0\\) must lie outside the unit circle. This can be explained as below Using the backshift notation we can write \\(AR(1)\\) process as \\[Y_t = \\phi_0 + \\phi_1BY_{t} + \\epsilon_t.\\] Then we get \\[(1-\\phi_1B)Y_t=\\phi_0 + \\epsilon_t.\\] The \\(AR(1)\\) process is said to be stationary if the roots of \\((1-\\phi_1B)=0\\) lie outside the unit circle. 2.5.1.1.3 Covariance The covariance \\(\\gamma_k=Cov(Y_t, Y_{t-k})\\) is called the lag-\\(k\\) autocovariance of \\(Y_t\\). The two main properties of \\(\\gamma_k\\): (a) \\(\\gamma_0=Var(Y_t)\\) and (b) \\(\\gamma_{-k}=\\gamma_{k}\\). The lag-\\(k\\) autocovariance of \\(Y_t\\) is \\[\\begin{equation} \\label{eq:3} \\begin{aligned} \\gamma_k &amp;= Cov(Y_t, Y_{t-k}) \\\\ &amp;= E[(Y_t-\\mu)(Y_{t-k}-\\mu)] \\\\ &amp;= E[Y_tY_{t-k}-Y_t\\mu-\\mu Y_{t-k} +\\mu^2] \\\\ &amp;= E(Y_t Y_{t-k}) - \\mu^2. \\\\ \\end{aligned} \\end{equation}\\] Now we have \\[\\begin{equation} \\label{eq:3} E(Y_t Y_{t-k}) = \\gamma_k + \\mu^2 \\end{equation}\\] 2.5.1.1.4 Autocorrelation function of an AR(1) process To derive autocorrelation function of an AR(1) process we first multiply both sides of Equation (??) by \\(Y_{t-k}\\) and take expected values: \\[E(Y_tY_{t-k})=\\phi_0E(Y_{t-k})+\\phi_1 E(Y_{t-1}Y_{t-k})+E(\\epsilon_tY_{t-k})\\] Since \\(\\epsilon_t\\) and \\(Y_{t-k}\\) are independent and using the results in Equation (??) \\[\\gamma_k + \\mu^2 = \\phi_0 \\mu+\\phi_1(\\gamma_{k-1}+\\mu^2)\\] Substituting the results in Equation (??) to Equation (??) we get \\[\\begin{equation} \\label{eq:5} \\gamma_k = \\phi_1 \\gamma_{k-1}. \\end{equation}\\] The autocorrelation function, \\(\\rho_k\\), is defined as \\[\\rho_k = \\frac{\\gamma_k}{\\gamma_0}\\]. Setting \\(k=1\\), we get \\(\\gamma_1 = \\phi_1\\gamma_0.\\) Hence, \\[\\rho_1=\\phi_1.\\] Similarly with \\(k=2\\), \\(\\gamma_2 = \\phi_1 \\gamma_1\\). Dividing both sides by \\(\\gamma_0\\) and substituting with \\(\\rho_1=\\phi_1\\) we get \\[\\rho_2=\\phi_1^2.\\] Now it is easy to see that in general \\[\\begin{equation} \\label{eq:acfar1} \\rho_k = \\frac{\\gamma_k}{\\gamma_0}=\\phi_1^k \\end{equation}\\] for \\(k=0, 1, 2, 3, ...\\). Since \\(|\\phi_1| &lt; 1,\\) the autocorrelation function is an exponentially decreasing as the number of lags \\(k\\) increases. There are two features in the ACF of AR(1) process depending on the sign of \\(\\phi_1\\). They are, If \\(0 &lt; \\phi_1 &lt; 1,\\) all correlations are positive. if \\(-1 &lt; \\phi_1 &lt; 0,\\) the lag 1 autocorrelation is negative (\\(\\rho_1=\\phi_1\\)) and the signs of successive autocorrelations alternate from positive to negative with their magnitudes decreasing exponentially. 2.5.1.2 Properties of AR(2) model Now consider a second-order autoregressive process (AR(2)) \\[\\begin{equation} \\label{eq:ar2} Y_t=\\phi_0+\\phi_1Y_{t-1}+\\phi_2Y_{t-2}+\\epsilon_t. \\end{equation}\\] 2.5.1.2.1 Mean Question 1: Using the same technique as that of the AR(1), show that \\[E(Y_t) = \\mu = \\frac{\\phi_0}{1-\\phi_1 - \\phi_2}\\] and the mean of \\(Y_t\\) exists if \\(\\phi_1 + \\phi_2 \\neq 1\\). 2.5.1.2.2 Variance Question 2: Show that \\[Var(Y_t) = \\frac{(1-\\phi_2)\\sigma^2}{(1+\\phi_2)((1+\\phi_2)^2-\\phi_1^2)}.\\] Here is a guide to the solution Start with \\[Var(Y_t)=Var(\\phi_0+\\phi_1Y_{t-1}+\\phi_2Y_{t-2}+\\epsilon_t)\\] Solve it until you obtain the Eq. (a) as shown below. \\[\\begin{equation} \\tag{a} \\gamma_0 (1-\\phi_1^2 - \\phi_2^2) = 2\\phi_1\\phi_2\\gamma_1+\\sigma^2. \\end{equation}\\] Next multiply both sides of Equation (??) by \\(Y_{t-1}\\) and obtain an expression for \\(\\gamma_1\\). Let’s call this Eq. (b). Solve Eq. (a) and (b) for \\(\\gamma_0.\\) 2.5.1.2.3 Stationarity of AR(2) process To discuss the stationarity condition of the \\(AR(2)\\) process we use the roots of the characteristic polynomial. Here is the illustration. Using the backshift notation we can write \\(AR(2)\\) process as \\[Y_t = \\phi_0 + \\phi_1 BY_{t} + \\phi_2 B^2 Y_{t} + \\epsilon_t.\\] Furthermore, we get \\[(1-\\phi_1 B - \\phi_2 B^2) Y_t = \\phi_0 + \\epsilon_t.\\] The characteristic polynomial of \\(AR(2)\\) process is \\[\\Phi(B)=1-\\phi_1 B - \\phi_2 B^2.\\] and the corresponding AR characteristic equation \\[1-\\phi_1 B - \\phi_2 B^2=0.\\] For stationarity, the roots of AR characteristic equation must lie outside the unit circle. The two roots of the AR characteristic equation are \\[\\frac{\\phi_1 \\pm \\sqrt{\\phi_1^2 + 4\\phi_2}}{-2\\phi_2}\\] Using algebraic manipulation, we can show that these roots will exceed 1 in modulus if and only if simultaneously \\(\\phi_1 + \\phi_2 &lt; 1,\\) \\(\\phi_2-\\phi_1 &lt; 1,\\) and \\(|\\phi_2| &lt; 1.\\) This is called the stationarity condition of \\(AR(2)\\) process. 2.5.1.2.4 Autocorrelation function of an AR(2) process To derive autocorrelation function of an AR(2) process we first multiply both sides of Equation (??) by \\(Y_{t-k}\\) and take expected values: \\[\\begin{align} E(Y_tY_{t-k}) &amp;= E(\\phi_0Y_{t-k}+\\theta_1Y_{t-1}Y_{t-k}+\\theta_2Y_{t-2}Y_{t-k}+\\epsilon_tY_{t-k} )\\\\ &amp;= \\phi_0 E(Y_{t-k})+\\phi_{1}E(Y_{t-1}Y_{t-k}) + \\phi_2 E(Y_{t-2} Y_{t-k}) + E(\\epsilon_tY_{t-k}). \\end{align}\\] Using the independence between \\(\\epsilon_t\\) and \\(Y_{t-1}\\), \\(E(\\epsilon_t Y_{t-k})=0\\) and the results in Equation (??) (This is valid for AR(2)) we have \\[\\gamma_k + \\mu^2 = \\phi_0 \\mu + \\theta_1 (\\gamma_{k-1}+\\mu^2)+\\phi_2 (\\gamma_{k-2}+\\mu^2).\\] (Note that \\(E(X_{t-1}X_{t-k})=E(X_{t-1}X_{(t-1)-(k-1)}=\\gamma_{k-1})\\)) Solving for \\(\\gamma_k\\) we get \\[\\begin{align} \\label{eq:eq9} \\gamma_k=\\phi_1\\gamma_{k-1}+\\phi_2\\gamma_{k-2}. \\end{align}\\] By dividing both sides of Equation (??) by \\(\\gamma_0\\), we have \\[\\begin{align} \\label{eq:yule2} \\rho_k=\\phi_1\\rho_{k-1}+\\phi_2\\rho_{k-2}. \\end{align}\\] for \\(k&gt;0\\). Setting \\(k=1\\) and using \\(\\rho_0=1\\) and \\(\\rho_{-1}=\\rho_1\\), we get the Yule-Walker equation for \\(AR(2)\\) process. \\[\\rho_1=\\phi_1+\\phi_2 \\rho_1\\] or \\[\\rho_1 = \\frac{\\phi_1}{1-\\phi_2}.\\] Similarly, we can show that \\[\\rho_2 = \\frac{\\phi_2(1-\\phi_2)+\\phi_1^2}{(1-\\phi_2)}.\\] 2.5.1.3 Properties of AR(p) model The \\(p\\)th order autoregressive model can be written as \\[\\begin{align} Y_t = \\phi_0 + \\phi_1Y_{t-1}+\\phi_2 Y_{t-2}+ ... + \\phi_p Y_{t-p}+\\epsilon_t. \\end{align}\\] The AR characteristic equation is \\[1-\\phi_1B-\\phi_2B^2-...-\\phi_pB^p=0.\\] For stationarity of \\(AR(p)\\) process, the \\(p\\) roots of the AR characteristic must lie outside the unit circle. 2.5.1.3.1 Mean Question 3: Find \\(E(Y_t)\\) of \\(AR(p)\\) process. 2.5.1.3.2 Variance Question 4: Find \\(Var(Y_t)\\) of \\(AR(p)\\) process. 2.5.1.3.3 Autocorrelation function (ACF) of an AR(p) process Question 5: Similar to the results in Equation (??) for \\(AR(2)\\) process, obtain the following recursive relationship for \\(AR(p)\\). \\[\\begin{align} \\label{eq:yulep} \\rho_k = \\phi_1\\rho_{k-1}+\\phi_2 \\rho_{k-2} + ... + \\phi_p \\rho_{k-p}. \\end{align}\\] Setting \\(k=1, 2, ..., p\\) into Equation (??) and using \\(\\rho_0=1\\) and \\(\\rho_{-k}=\\rho_k\\), we get the Yule-Walker equations for \\(AR(p)\\) process \\[\\begin{equation} \\label{eq:13} \\begin{aligned} \\rho_1 &amp;= \\phi_1+\\phi_2 \\rho_{1} + ... + \\phi_p \\rho_{p-1}\\\\ \\rho_2 &amp;= \\phi_1 \\rho_1+\\phi_2 + ... + \\phi_p \\rho_{p-2}\\\\ ... \\\\ \\rho_p &amp;= \\phi_1 \\rho_{p-1} +\\phi_2 \\rho_{p-2} + ... + \\phi_p \\\\ \\end{aligned} \\end{equation}\\] The Yule-Walker equations in (??) can be written in matrix form as below. \\[\\left[\\begin{array} {r} \\rho_1 \\\\ \\rho_2 \\\\ .\\\\ .\\\\ .\\\\ \\rho_p \\end{array}\\right] = \\left[\\begin{array} {rrrrrrr} 1 &amp; \\rho_1 &amp; \\rho_2 &amp; .&amp;.&amp;.&amp; \\rho_{p-1} \\\\ \\rho_1 &amp; 1 &amp; \\rho_1 &amp; .&amp;.&amp;.&amp; \\rho_{p-2} \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ \\rho_{p-1} &amp; \\rho_{p-2} &amp; \\rho_{p-3} &amp; .&amp;.&amp;.&amp; 1 \\\\ \\end{array}\\right] \\left[\\begin{array} {r} \\phi_1 \\\\ \\phi_2 \\\\ .\\\\ .\\\\ .\\\\ \\phi_p \\end{array}\\right] \\] or \\[\\symbf{{\\rho_{p}}} = \\symbf{{P_{p}\\phi}}.\\] where, \\[\\symbf{\\rho_p} = \\left[\\begin{array} {r} \\rho_1 \\\\ \\rho_2 \\\\ .\\\\ .\\\\ .\\\\ \\rho_p \\end{array}\\right], \\mathbf{P_p} = \\left[\\begin{array} {rrrrrrr} 1 &amp; \\rho_1 &amp; \\rho_2 &amp; .&amp;.&amp;.&amp; \\rho_{p-1} \\\\ \\rho_1 &amp; 1 &amp; \\rho_1 &amp; .&amp;.&amp;.&amp; \\rho_{p-2} \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ \\rho_{p-1} &amp; \\rho_{p-2} &amp; \\rho_{p-3} &amp; .&amp;.&amp;.&amp; 1 \\\\ \\end{array}\\right], \\symbf{{\\phi}} = \\left[\\begin{array} {r} \\phi_1 \\\\ \\phi_2 \\\\ .\\\\ .\\\\ .\\\\ \\phi_p \\end{array}\\right]\\] The parameters can be estimated using \\[\\symbf{\\phi}=\\symbf{P_p^{-1}\\rho_p}.\\] Question 6: Obtain the parameters of an \\(AR(3)\\) process whose first autocorrelations are \\(\\rho_1=0.9\\); \\(\\rho_2=0.9\\); \\(\\rho_3=0.5\\). Is the process stationary? 2.5.1.3.4 The partial autocorrelation function (PACF) Let \\(\\phi_{kj}\\), the \\(j\\)th coefficient in an \\(AR(k)\\) model. Then, \\(\\phi_{kk}\\) is the last coefficient. From Equation (??), the \\(\\phi_{kj}\\) satisfy the set of equations \\[\\begin{equation} \\label{eq:pacf} \\rho_j=\\phi_{k1}\\rho_{j-1}+...+\\phi_{k(k-1)}\\rho_{j-k+1}+\\phi_{kk}\\rho_{j-k}, \\end{equation}\\] for \\(j=1, 2, ...k\\), leading to the Yule-Walker equations which may be written \\[\\begin{equation} \\label{eq:pacf} \\left[\\begin{array} {r} \\rho_1 \\\\ \\rho_2 \\\\ .\\\\ .\\\\ .\\\\ \\rho_k \\end{array}\\right] = \\left[\\begin{array} {rrrrrrr} 1 &amp; \\rho_1 &amp; \\rho_2 &amp; .&amp;.&amp;.&amp; \\rho_{k-1} \\\\ \\rho_1 &amp; 1 &amp; \\rho_1 &amp; .&amp;.&amp;.&amp; \\rho_{k-2} \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ \\rho_{k-1} &amp; \\rho_{k-2} &amp; \\rho_{k-3} &amp; .&amp;.&amp;.&amp; 1 \\\\ \\end{array}\\right] \\left[\\begin{array} {r} \\phi_{k1} \\\\ \\phi_{k2} \\\\ .\\\\ .\\\\ .\\\\ \\phi_{kk} \\end{array}\\right] \\end{equation}\\] or \\[\\symbf{\\rho_k}=\\symbf{P_k\\phi_k}.\\] where \\[\\symbf{\\rho_k} = \\left[\\begin{array} {r} \\rho_1 \\\\ \\rho_2 \\\\ .\\\\ .\\\\ .\\\\ \\rho_k \\end{array}\\right], \\mathbf{P_k} =\\left[\\begin{array} {rrrrrrr} 1 &amp; \\rho_1 &amp; \\rho_2 &amp; .&amp;.&amp;.&amp; \\rho_{k-1} \\\\ \\rho_1 &amp; 1 &amp; \\rho_1 &amp; .&amp;.&amp;.&amp; \\rho_{k-2} \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ . &amp; . &amp; . &amp; .&amp;.&amp;.&amp; . \\\\ \\rho_{k-1} &amp; \\rho_{k-2} &amp; \\rho_{k-3} &amp; .&amp;.&amp;.&amp; 1 \\\\ \\end{array}\\right], \\symbf{\\phi_k} = \\left[\\begin{array} {r} \\phi_{k1} \\\\ \\phi_{k2} \\\\ .\\\\ .\\\\ .\\\\ \\phi_{kk} \\end{array}\\right]\\] For each \\(k\\), we compute the coefficients \\(\\phi_{kk}\\). Solving the equations for \\(k=1, 2, 3...\\) successively, we obtain For \\(k=1\\), \\[\\begin{equation} \\label{eq:p1} \\phi_{11}=\\rho_1. \\end{equation}\\] For \\(k=2\\), \\[\\begin{equation} \\label{eq:p2} \\phi_{22}=\\frac{\\left[\\begin{array} {rr} 1 &amp; \\rho_1 \\\\ \\rho_1 &amp; \\rho_2 \\\\ \\end{array}\\right]}{\\left[\\begin{array} {rr} 1 &amp; \\rho_1 \\\\ \\rho_1 &amp; 1 \\\\ \\end{array}\\right]} = \\frac{\\rho_2-\\rho_1^2}{1-\\rho_1^2} \\end{equation}\\] For \\(k=3\\), \\[\\begin{equation} \\label{eq:p3} \\phi_{33}=\\frac{\\left[\\begin{array} {rrr} 1 &amp; \\rho_1 &amp; \\rho_1 \\\\ \\rho_1 &amp; 1 &amp; \\rho_2 \\\\ \\rho_2 &amp; \\rho_1 &amp; \\rho_3 \\\\ \\end{array}\\right]}{\\left[\\begin{array} {rrr} 1 &amp; \\rho_1 &amp; \\rho_2 \\\\ \\rho_1 &amp; 1 &amp; \\rho_1 \\\\ \\rho_2 &amp; \\rho_1 &amp; 1 \\\\ \\end{array}\\right]} \\end{equation}\\] The quantity \\(\\phi_{kk}\\) is called the partial autocorrelation at lag \\(k\\) and can be defined as \\[\\phi_{kk}=Corr(Y_tY_{t-k}|Y_{t-1}, Y_{t-2},..., Y_{t-k+1}).\\] The partial autocorrelation between \\(Y_t\\) and \\(Y_{t-k}\\) is the correlation between \\(Y_t\\) and \\(Y_{t-k}\\) after removing the effect of the intermediate variables \\(Y_{t-1}, Y_{t-2}, ..., Y_{t-k+1}\\). In general the determinant in the numerator of Equations (??), (??) and (??) has the same elements as that in the denominator, but replacing the last column with \\(\\symbf{\\rho_k}= (\\rho_1, \\rho_2,...\\rho_k).\\) 2.5.1.3.5 PACF for AR(1) models From Equation (??) we have \\(\\rho_k=\\phi_1^k\\) for \\(k=0, 1, 2, 3,...\\) Hence, for \\(k=1\\), the first partial autocorrelation coefficient is \\[\\phi_{11}=\\rho_1=\\phi_1.\\] From (??) for \\(k=2\\), the second partial autocorrelation coefficient is \\[\\phi_{22}=\\frac{\\rho_2-\\rho_1^2}{1-\\rho_1^2}=\\frac{\\phi_1^2-\\phi_1^2}{1-\\phi_1^2} = 0\\]. Similarly, for \\(AR(1)\\) we can show that \\(\\phi_{kk}=0\\) for all \\(k &gt; 1\\). Hence, for \\(AR(1)\\) process the partial autocorrelation is non-zero for lag \\(1\\) which is the order of the process, but is zero for lags beyond the order 1. 2.5.1.3.6 PACF for AR(2) model Question 7: For \\(AR(2)\\) process show that \\(\\phi_{kk}=0\\) for all \\(k&gt;2\\). Sketch the PACF of \\(AR(2)\\) process. 2.5.1.3.7 PACF for AR(P) model In general for \\(AR(p)\\) process, the partial autocorrelation function \\(\\phi_{kk}\\) is non-zero for \\(k\\) less than or equal to \\(p\\) (the order of the process) and zero for all \\(k\\) greater than \\(p\\). In other words, the partial autocorrelation function of a \\(AR(p)\\) process has a cut-off after lag \\(p\\). 2.5.2 Moving average (MA) models We first derive the properties of \\(MA(1)\\) and \\(MA(2)\\) models and then give the results for the general \\(MA(q)\\) model. 2.5.2.1 Properties of MA(1) model The general form for \\(MA(1)\\) model is \\[\\begin{equation} \\label{eq:ma1} Y_t = \\theta_0 + \\theta_1 \\epsilon_{t-1} + \\epsilon_t \\end{equation}\\] where \\(\\theta_0\\) is a constant and \\({\\epsilon_t}\\) is a white noise series. 2.5.2.1.1 Mean Question 8: Show that \\(E(Y_t) = \\theta_0\\). 2.5.2.1.2 Variance Question 9: Show that \\(Var(Y_t) = (1+\\theta_1^2)\\sigma^2\\). We can see both mean and variance are time-invariant. \\(MA\\) models are finite linear combinations of a white noise sequence. Hence, \\(MA\\) processes are always weakly stationary. 2.5.2.1.3 Autocorrelation function of an MA(1) process Method 1 To obtain the autocorrelation function of \\(MA(1)\\), we first multiply both sides of Equation (??) by \\(Y_{t-k}\\) and take the expectation. \\[\\begin{equation} \\label{eq: ma1acfs1} \\begin{aligned} E[Y_tY_{t-k}] &amp;= E[\\theta_0 Y_{t-k} + \\theta_1 \\epsilon_{t-1} Y_{t-k} + \\epsilon_t Y_{t-k}]\\\\ &amp;= \\theta_0 E(Y_{t-k}) + \\theta_1 E(\\epsilon_{t-1}Y_{t-k}) + E(\\epsilon_t Y_{t-k})\\\\ \\end{aligned} \\end{equation}\\] Using the independence between \\(\\epsilon_t\\) and \\(Y_{t-k}\\) (future error and past observation) \\(E(\\epsilon_t Y_{t-k}) = 0\\). Now we have \\[\\begin{equation} \\label{eq:ma1acfs2} E[Y_tY_{t-k}] = \\theta_0^2 + \\theta_1 E(\\epsilon_{t-1}Y_{t-k}) \\end{equation}\\] Now let’s obtain an expression for \\(E[Y_t Y_{t-k}]\\). \\[\\begin{equation} \\label{eq:covma1} \\begin{aligned} \\gamma_k &amp;= Cov(Y_t, Y_{t-k}) \\\\ &amp;= E[(Y_t-\\theta_0)(Y_{t-k}-\\theta_0)] \\\\ &amp;= E[Y_tY_{t-k}-Y_t\\theta_0-\\theta_0 Y_{t-k} +\\theta_0^2] \\\\ &amp;= E(Y_t Y_{t-k}) - \\theta_0^2. \\\\ \\end{aligned} \\end{equation}\\] Now we have \\[\\begin{equation} \\label{eq:covma1} E(Y_t Y_{t-k}) = \\gamma_k + \\theta_0^2. \\end{equation}\\] Using the Equations (??) and (??) we have \\[\\begin{equation} \\label{eq:covma2} \\gamma_k = \\theta_0^2 - \\theta_0^2 + \\theta_1E(\\epsilon_{t-1}Y_{t-k}). \\end{equation}\\] Now let’s consider the case \\(k=1\\). \\[\\begin{equation} \\label{eq:covma3} \\gamma_1 = \\theta_0^2 - \\theta_0^2 + \\theta_1E(\\epsilon_{t-1}Y_{t-1}) \\end{equation}\\] Today’s error and today’s value are dependent. Hence, \\(E(\\epsilon_{t-1}Y_{t-1}) \\neq 0.\\) We first need to identify \\(E(\\epsilon_{t-1}Y_{t-1})\\). \\[\\begin{equation} \\label{eq:covma4} \\begin{aligned} E(\\epsilon_{t-1}Y_{t-1}) &amp;= E(\\theta_0 \\epsilon_{t-1} + \\theta_1 \\epsilon_{t-2} \\epsilon_{t-1}+ \\epsilon_{t-1}^2)\\\\ \\end{aligned} \\end{equation}\\] Since, {\\(\\epsilon_t\\)} is a white noise process \\(E(\\epsilon_{t-1}) = 0\\) and \\(E(\\epsilon_{t-2} \\epsilon_{t-1}) = 0\\). Hence, we have \\[\\begin{equation} \\label{eq:covma5} \\begin{aligned} E(\\epsilon_{t-1}Y_{t-1}) &amp;= E(\\epsilon_{t-1}^2)=\\sigma^2\\\\ \\end{aligned} \\end{equation}\\] Substituting (??) in (??) we get \\[\\gamma_1=\\theta_1\\sigma^2\\]. Furthermore, \\(\\gamma_0 = Var(Y_t)= (1+\\theta_1^2)\\sigma^2\\). Hence \\[\\rho_1=\\frac{\\gamma_1}{\\gamma_0}=\\frac{\\theta_1}{1+\\theta_1^2}.\\] When \\(k=2\\), from Equation (??) and \\(E(\\epsilon_{t-1}Y_{t-2}) = 0\\) (future error and past observation) we get \\(\\gamma_2=0\\). Hence \\(\\rho_2=0\\). Similarly, we can show that \\[\\gamma_k = \\rho_k=0\\] for all \\(k \\geq 2\\). We can see that the ACF of \\(MA(1)\\) process is zero, beyond the order of 1 of the process. Method 2: By using the definition of covariance \\[\\begin{equation} \\label{eq:mtd21} \\begin{aligned} \\gamma_1 = Cov(Y_t, Y_{t-1}) &amp;= Cov(\\epsilon_t + \\theta_1 \\epsilon_{t-1}+ \\theta_0, \\epsilon_{t-1}+\\theta_1 \\epsilon_{t-2} + \\theta_0)\\\\ &amp;=Cov(\\theta_1 \\epsilon_{t-1}, \\epsilon_{t-1})\\\\ &amp;=\\theta_1 \\sigma^2. \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq:mtd21} \\begin{aligned} \\gamma_2=Cov(Y_t, Y_{t-2}) &amp;= Cov(\\epsilon_t + \\theta_1 \\epsilon_{t-1}+ \\theta_0, \\epsilon_{t-2}+\\theta_1 \\epsilon_{t-3} + \\theta_0)\\\\ &amp;=0. \\end{aligned} \\end{equation}\\] We have \\(\\gamma_0=\\sigma^2(1+\\theta_1^2)\\), (Using the variance). Hence \\[\\rho_1=\\frac{\\gamma_1}{\\gamma_0}=\\frac{\\theta_1}{1+\\theta_1^2}.\\] Similarly we can show \\(\\gamma_k=\\rho_k=0\\) for all \\(k \\geq 2\\). 2.5.2.2 Properties of MA(2) model An \\(MA(2)\\) model is in the form \\[\\begin{equation} \\label{eq:ma2} Y_t = \\theta_0 + \\theta_1 \\epsilon_{t-1} + \\theta_2 \\epsilon_{t-2} + \\epsilon_t \\end{equation}\\] where \\(\\theta_0\\) is a constant and \\({\\epsilon_t}\\) is a white noise series. 2.5.2.2.1 Mean Question 10: Show that \\(E(Y_t) = \\theta_0.\\) 2.5.2.2.2 Variance Question 11: Show that \\(Var(Y_t) = \\sigma^2 (1+\\theta_1^2 + \\theta_2^2).\\) 2.5.2.2.3 Autocorrelation function of an MA(2) process Question 12: For \\(MA(2)\\) process show that, \\[\\rho_1=\\frac{\\theta_1(1+\\theta_2)}{1+\\theta_1^2+\\theta_2^2},\\] \\[\\rho_2 = \\frac{\\theta_2}{1+\\theta_1^2 + \\theta_2^2},\\] and \\(\\rho_k=0\\) for all \\(k \\geq 3.\\) 2.5.2.3 Properties of MA(q) model \\[\\begin{equation} \\label{eq:ma2} Y_t = \\theta_0 + \\theta_1 \\epsilon_{t-1} + \\theta_2 \\epsilon_{t-2} +...+ \\theta_q \\epsilon_{t-q} +\\epsilon_t \\end{equation}\\] where \\(\\theta_0\\) is a constant and \\({\\epsilon_t}\\) is a white noise series. 2.5.2.3.1 Mean Question 13: Show that the constant term of an \\(MA\\) model is the mean of the series (i.e. \\(E(Y_t)=\\theta_0\\)). 2.5.2.3.2 Variance Question 14: Show that the variance of an \\(MA\\) model is \\[Var(Y_t)=(1+\\theta_1^2+\\theta_2^2+...+\\theta_q^2)\\sigma^2.\\] 2.5.2.3.3 Autocorrelation function of an MA(q) process Question 15: Show that the autocorrelation function of a \\(MA(q)\\) process is zero, beyond the order of \\(q\\) of the process. In other words, the autocorrelation function of a moving average process has a cutoff after lag \\(q\\). 2.5.2.3.4 Partial autocorrelation function of an MA(q) process The partial autocorrelation functions for \\(MA(q)\\) models behave very much like the autocorrelation functions of \\(AR(p)\\) models. The PACF of \\(MA\\) models decays exponentially to zero, rather like ACF for \\(AR\\) model. 2.5.3 Dual relation between AR and MA process Dual relation 1 First we consider the relation AR(p) &lt;–&gt; MA(\\(\\infty\\)) Let \\(AR(p)\\) be a stationary \\(AR\\) model with order \\(p\\). Then, \\[Y_t = \\phi_1Y_{t-1}+ \\phi_2Y_{t-2}+...+ \\phi_pY_{t-p}+\\epsilon_t,\\] where \\(\\epsilon_t \\sim WN(0, \\sigma^2).\\) Using the backshift operator we can write the \\(AR(p)\\) model as \\[(1-\\phi_1B-\\phi_2B^2-...-\\phi_pB^P)Y_t=\\epsilon_t.\\] Then \\[\\phi(B)Y_t=\\epsilon_t,\\] where \\(\\phi(B)=1-\\phi_1B-\\phi_2B^2-...-\\phi_pB^p.\\) Furthermore, \\(Y_t\\) can be written as infinite sum of previous \\(\\epsilon\\)’s as below \\[Y_t = \\phi^{-1}(B)\\epsilon_t,\\] where \\(\\phi(B)\\psi(B)=1\\) and \\(\\psi(B)=1+\\Psi_1B+\\psi_2B^2+...\\) Then \\[Y_t=\\psi(B)\\epsilon_t.\\] This is a representation of \\(MA(\\infty)\\) process. Next, we consider the relation MA(q) &lt;–&gt; AR(\\(\\infty\\)) Let \\(MA(q)\\) be invertible moving average process \\[Y_t = \\epsilon_t + \\theta_t\\epsilon_{t-1}+\\theta_2\\epsilon_{t-2}+...+\\theta_p\\epsilon_{t-q}.\\] Using the backshift operator we can write the \\(MA(q)\\) process as \\[Y_t = (1+\\theta_1B+\\theta_2B^2-...+\\theta_qB^q)\\epsilon_t.\\] Then, \\[Y_t = \\theta(B)\\epsilon_t,\\] where \\(\\theta(B)=1+\\theta_1B+\\theta_2B^2+...+\\theta_1B^q.\\) Hence, for an invertible moving average process, \\(Y_t\\) can be represented as a finite weighted sum of previous error terms, \\(\\epsilon\\). Furthermore, since the process is invertible \\(\\epsilon_t\\) can be represented as an infinite weighted sum of previous \\(Y\\)’s as below \\[\\epsilon_t=\\theta^{-1}(B)Y_t,\\] where \\(\\pi(B)\\theta(B)=1\\), and \\(\\pi(B) = 1+\\pi_1B+\\pi B^2+...\\). Hence, \\[\\epsilon_t = \\pi(B)Y_t.\\] This is an representation of a \\(AR(\\infty)\\) process. Dual relation 2 An \\(MA(q)\\) process has an ACF function that is zero beyond lag \\(q\\) and its PACF is decays exponentially to 0. Consequently, an \\(AR(p)\\) process has an PACF that is zero beyond lag-\\(p\\), but its ACF decays exponentially to 0. Dual relation 3 For an \\(AR(p)\\) process the roots of \\(\\phi(B)=0\\) must lie outside the unit circle to satisfy the condition of stationarity. However, the parameters of the \\(AR(p)\\) are not required to satisfy any conditions to ensure invertibility. Conversely, the parameters of the \\(MA\\) process are not required to satisfy any condition to ensure stationarity. However, to ensure the condition of invertibility, the roots of \\(\\theta(B)=0\\) must lie outside the unit circle. 2.5.4 Autoregressive and Moving-average (ARMA) models current value = linear combination of past values + linear combination of past error + current error The \\(ARMA(p, q)\\) can be written as \\[Y_t=c+\\phi_1 Y_{t-1}+\\phi_2 Y_{t-2}+...+\\phi_p Y_{t-p}+\\theta_1\\epsilon_{t-1}+\\theta_2\\epsilon_{t-2}+...+\\theta_q\\epsilon_{t-q}+\\epsilon_t,\\] where \\(\\{\\epsilon_t\\}\\) is a white noise process. Using the back shift operator \\[\\phi(B)Y_t=\\theta(B)\\epsilon_t,\\] where \\(\\phi(.)\\) and \\(\\theta(.)\\) are the \\(p\\)th and \\(q\\)th degree polynomials, \\[\\phi(B)=1-\\phi_1 \\epsilon -...-\\phi_p \\epsilon^p,\\] and \\[\\theta(B)=1+\\theta_1\\epsilon+...+\\theta_q\\epsilon^q.\\] 2.5.4.1 Stationary condition Roots of \\[\\phi(B)=0\\] lie outside the unit circle. 2.5.4.2 Invertible condition Roots of \\[\\theta(B)=0\\] lie outside the unit circle. 2.5.4.3 Autocorrelation function and Partial autocorrelation function The ACF of an ARMA model exhibits a pattern similar to that of an AR model. The PACF of ARMA process behaves like the PACF of a MA process. Hence, the ACF and PACF are not informative in determining the order of an ARMA model. 2.6 Unit root tests Many financial time series are with trending behavior or nonstationarity in the mean. Two common trend removal or de-trending procedures First differencing (appropriate for \\(I(1)\\) time series). time-trend regression (appropriate for trend stationary \\(I(0)\\) time series). Unit root tests are statistical tests to determine the required order of differencing or whether it should be regressed on deterministic functions of time to render the data stationary. 2.6.1 Dickey-Fuller test Consider the model \\[\\Delta y_t = c+ \\beta y_{t-1}+\\epsilon_{t}\\] Hypothesis to be tested \\(H_0: \\beta = 0\\) and \\(H_1: \\beta&lt;0\\) Test statistics = \\(\\frac{\\hat{\\beta}}{SE(\\hat{\\beta})}\\) 2.6.2 Augmented Dickey-Fuller test The Dickey-Fuller Unit Root Test is valid if the time series \\(y_t\\) is well characterized by an AR(1) model with white noise errors. Many financial time series have a more complicated dynamic structures The Augmented Dickey-Fuller (ADF) test allows for higher-order autoregressive processes by including \\(\\Delta y_{t−p}\\) in the model. The number of lags included in the model should be just sufficient to remove any autocorrelation in errors. Consider the model: \\[\\Delta y_t = c+ \\beta y_{t-1}+ \\alpha_1 \\Delta y_{t-1}+\\dots + \\alpha_p \\Delta y_{t-p} +\\epsilon_{t}\\] Hypothesis to be tested \\(H_0: \\beta = 0\\) and \\(H_1: \\beta&lt;0\\) ADF test: null hypothesis is that the data are non-stationary and non-seasonal. DF and ADF tests are not suitable when there is a deterministic trend Alternative tests: Phillips-Perron Unit Root Tests The main difference between Phillips-Perron (PP) unit root tests and the ADF tests is in the way they deal with serial correlation and heteroskedasticity in the errors. 2.6.3 Stationarity Tests The ADF unit root test tests the null hypothesis that a time series \\(y_t\\) is \\(I(1)\\). In contrast, Stationarity tests are for the null that \\(y_t\\) is \\(I(0)\\). Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test is the most commonly used stationarity test that tests the null hypothesis that the data are stationary and non-seasonal. Other tests available for seasonal data 2.6.3.1 Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test google_2018 %&gt;% features(Close, unitroot_kpss) ## # A tibble: 1 x 3 ## Symbol kpss_stat kpss_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GOOG 0.573 0.0252 google_2018 %&gt;% mutate(diff_close = difference(Close)) %&gt;% features(diff_close, unitroot_kpss) ## # A tibble: 1 x 3 ## Symbol kpss_stat kpss_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GOOG 0.0955 0.1 google_2018 %&gt;% features(Close, unitroot_ndiffs) ## # A tibble: 1 x 2 ## Symbol ndiffs ## &lt;chr&gt; &lt;int&gt; ## 1 GOOG 1 2.6.3.2 Automatically selecting differences STL decomposition: \\(y_t = T_t+S_t+R_t\\) Seasonal strength \\(F_s = \\max\\big(0, 1-\\frac{\\text{Var}(R_t)}{\\text{Var}(S_t+R_t)}\\big)\\) If \\(F_s &gt; 0.64\\), do one seasonal difference. usmelec %&gt;% mutate(log_gen = log(Generation)) %&gt;% features(log_gen, list(unitroot_nsdiffs, feat_stl)) ## # A tibble: 1 x 10 ## nsdiffs trend_strength seasonal_streng… seasonal_peak_y… ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.994 0.941 7 ## # … with 6 more variables: seasonal_trough_year &lt;dbl&gt;, ## # spikiness &lt;dbl&gt;, linearity &lt;dbl&gt;, curvature &lt;dbl&gt;, ## # stl_e_acf1 &lt;dbl&gt;, stl_e_acf10 &lt;dbl&gt; usmelec %&gt;% mutate(log_gen = log(Generation)) %&gt;% features(log_gen, unitroot_nsdiffs) ## # A tibble: 1 x 1 ## nsdiffs ## &lt;int&gt; ## 1 1 usmelec %&gt;% mutate(d_log_gen = difference(log(Generation), 12)) %&gt;% features(d_log_gen, unitroot_ndiffs) ## # A tibble: 1 x 1 ## ndiffs ## &lt;int&gt; ## 1 1 2.7 ARIMA modelling in R 2.7.1 How does ARIMA() work? A non-seasonal ARIMA process \\[\\phi(B)(1-B)^dy_{t} = c + \\theta(B)\\varepsilon_t\\] Need to select appropriate orders: \\(p,q, d\\) Hyndman and Khandakar (JSS, 2008) algorithm: Select no. differences \\(d\\) and \\(D\\) via KPSS test and seasonal strength measure. Select \\(p,q\\) by minimising AICc. Use step-wise search to traverse model space. \\[\\text{AICc} = -2 \\log(L) + 2(p+q+k+1)\\left[1 + \\frac{(p+q+k+2)}{T-p-q-k-2}\\right].\\] where \\(L\\) is the maximised likelihood fitted to the differenced data, \\(k=1\\) if \\(c\\neq 0\\) and \\(k=0\\) otherwise. Step1: Select current model (with smallest AICc) from: ARIMA\\((2,d,2)\\) ARIMA\\((0,d,0)\\) ARIMA\\((1,d,0)\\) ARIMA\\((0,d,1)\\) Step 2: Consider variations of current model: vary one of \\(p,q,\\) from current model by \\(\\pm1\\); \\(p,q\\) both vary from current model by \\(\\pm1\\); Include/exclude \\(c\\) from current model. Model with lowest AICc becomes current model. Repeat Step 2 until no lower AICc can be found. 2.7.2 Choosing your own model web_usage &lt;- as_tsibble(WWWusage) web_usage %&gt;% gg_tsdisplay(value, plot_type = &#39;partial&#39;) web_usage %&gt;% mutate(diff = difference(value)) %&gt;% gg_tsdisplay(diff, plot_type = &#39;partial&#39;) fit &lt;- web_usage %&gt;% model(arima = ARIMA(value ~ pdq(3, 1, 0))) report(fit) ## Series: value ## Model: ARIMA(3,1,0) ## ## Coefficients: ## ar1 ar2 ar3 ## 1.151 -0.6612 0.3407 ## s.e. 0.095 0.1353 0.0941 ## ## sigma^2 estimated as 9.656: log likelihood=-252 ## AIC=512 AICc=512.4 BIC=522.4 web_usage %&gt;% model(ARIMA(value ~ pdq(d=1))) %&gt;% report() ## Series: value ## Model: ARIMA(1,1,1) ## ## Coefficients: ## ar1 ma1 ## 0.6504 0.5256 ## s.e. 0.0842 0.0896 ## ## sigma^2 estimated as 9.995: log likelihood=-254.2 ## AIC=514.3 AICc=514.5 BIC=522.1 web_usage %&gt;% model(ARIMA(value ~ pdq(d=1), stepwise = FALSE, approximation = FALSE)) %&gt;% report() ## Series: value ## Model: ARIMA(3,1,0) ## ## Coefficients: ## ar1 ar2 ar3 ## 1.151 -0.6612 0.3407 ## s.e. 0.095 0.1353 0.0941 ## ## sigma^2 estimated as 9.656: log likelihood=-252 ## AIC=512 AICc=512.4 BIC=522.4 gg_tsresiduals(fit) augment(fit) %&gt;% features(.resid, ljung_box, lag = 10, dof = 3) ## # A tibble: 1 x 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 arima 4.49 0.722 fit %&gt;% forecast(h = 10) %&gt;% autoplot(web_usage) 2.7.3 Modelling procedure with ARIMA() Plot the data. Identify any unusual observations. If necessary, transform the data (using a Box-Cox transformation) to stabilize the variance. If the data are non-stationary: take first differences of the data until the data are stationary. Examine the ACF/PACF: Is an AR(\\(p\\)) or MA(\\(q\\)) model appropriate? Try your chosen model(s), and use the \\(AICc\\) to search for a better model. Check the residuals from your chosen model by plotting the ACF of the residuals, and doing a portmanteau test of the residuals. If they do not look like white noise, try a modified model. Once the residuals look like white noise, calculate forecasts. 2.7.4 Automatic modelling procedure with ARIMA() Plot the data. Identify any unusual observations. If necessary, transform the data (using a Box-Cox transformation) to stabilize the variance. Use ARIMA to automatically select a model. Check the residuals from your chosen model by plotting the ACF of the residuals, and doing a portmanteau test of the residuals. If they do not look like white noise, try a modified model. Once the residuals look like white noise, calculate forecasts. 2.7.5 Example in R Seasonally adjusted electrical equipment elecequip &lt;- as_tsibble(fpp2::elecequip) dcmp &lt;- elecequip %&gt;% model(STL(value ~ season(window = &quot;periodic&quot;))) %&gt;% components() %&gt;% select(-.model) dcmp %&gt;% as_tsibble %&gt;% autoplot(season_adjust) + xlab(&quot;Year&quot;) + ylab(&quot;Seasonally adjusted new orders index&quot;) dcmp %&gt;% mutate(diff = difference(season_adjust)) %&gt;% gg_tsdisplay(diff, plot_type = &#39;partial&#39;) fit &lt;- dcmp %&gt;% model(arima = ARIMA(season_adjust)) report(fit) ## Series: season_adjust ## Model: ARIMA(3,1,0) ## ## Coefficients: ## ar1 ar2 ar3 ## -0.3418 -0.0426 0.3185 ## s.e. 0.0681 0.0725 0.0682 ## ## sigma^2 estimated as 9.639: log likelihood=-493.8 ## AIC=995.6 AICc=995.8 BIC=1009 fit &lt;- dcmp %&gt;% model(arima = ARIMA(season_adjust, approximation=FALSE)) report(fit) ## Series: season_adjust ## Model: ARIMA(3,1,1) ## ## Coefficients: ## ar1 ar2 ar3 ma1 ## 0.0044 0.0916 0.3698 -0.3921 ## s.e. 0.2201 0.0984 0.0669 0.2426 ## ## sigma^2 estimated as 9.577: log likelihood=-492.7 ## AIC=995.4 AICc=995.7 BIC=1012 gg_tsresiduals(fit) augment(fit) %&gt;% features(.resid, ljung_box, lag = 24, dof = 4) ## # A tibble: 1 x 3 ## .model lb_stat lb_pvalue ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 arima 24.0 0.241 fit %&gt;% forecast %&gt;% autoplot(dcmp) 2.8 Forecasting 2.8.1 Point forecasts Rearrange ARIMA equation so \\(y_t\\) is on LHS. Rewrite equation by replacing \\(t\\) by \\(T+h\\). On RHS, replace future observations by their forecasts, future errors by zero, and past errors by corresponding residuals. Start with \\(h=1\\). Repeat for \\(h=2,3,\\dots\\). Example: ARIMA(3,1,1) forecasts: Step 1 \\[(1-\\phi_1B -\\phi_2B^2-\\phi_3B^3)(1-B) y_t = (1+\\theta_1B)\\varepsilon_{t},\\] \\[[1-(1+\\phi_1)B +(\\phi_1-\\phi_2)B^2 + (\\phi_2-\\phi_3)B^3 +\\phi_3B^4] y_t = (1+\\theta_1B)\\varepsilon_{t}\\] \\[y_t - (1+\\phi_1)y_{t-1} +(\\phi_1-\\phi_2)y_{t-2} + (\\phi_2-\\phi_3)y_{t-3} \\mbox{}+\\phi_3y_{t-4} = \\varepsilon_t+\\theta_1\\varepsilon_{t-1}.\\] \\[y_t = (1+\\phi_1)y_{t-1} -(\\phi_1-\\phi_2)y_{t-2} - (\\phi_2-\\phi_3)y_{t-3}\\\\\\mbox{} -\\phi_3y_{t-4} + \\varepsilon_t+\\theta_1\\varepsilon_{t-1}.\\] 2.8.1.1 Point forecasts (h=1) \\[y_t = (1+\\phi_1)y_{t-1} -(\\phi_1-\\phi_2)y_{t-2} - (\\phi_2-\\phi_3)y_{t-3}\\\\\\mbox{} -\\phi_3y_{t-4} + \\varepsilon_t+\\theta_1\\varepsilon_{t-1}.\\] ARIMA(3,1,1) forecasts: Step 2 \\[y_{T+1} = (1+\\phi_1)y_{T} -(\\phi_1-\\phi_2)y_{T-1} - (\\phi_2-\\phi_3)y_{T-2}\\\\\\mbox{} -\\phi_3y_{T-3} + \\varepsilon_{T+1}+\\theta_1\\varepsilon_{T}.\\] ARIMA(3,1,1) forecasts: Step 3 \\[\\hat{y}_{T+1|T} = (1+\\phi_1)y_{T} -(\\phi_1-\\phi_2)y_{T-1} - (\\phi_2-\\phi_3)y_{T-2}\\\\\\mbox{} -\\phi_3y_{T-3} + \\theta_1 e_{T}.\\] 2.8.1.2 Point forecasts (h=2) \\[y_t = (1+\\phi_1)y_{t-1} -(\\phi_1-\\phi_2)y_{t-2} - (\\phi_2-\\phi_3)y_{t-3}\\\\\\mbox{} -\\phi_3y_{t-4} + \\varepsilon_t+\\theta_1\\varepsilon_{t-1}.\\] ARIMA(3,1,1) forecasts: Step 2 \\[y_{T+2} = (1+\\phi_1)y_{T+1} -(\\phi_1-\\phi_2)y_{T} - (\\phi_2-\\phi_3)y_{T-1}\\\\\\mbox{} -\\phi_3y_{T-2} + \\varepsilon_{T+2}+\\theta_1\\varepsilon_{T+1}.\\] ARIMA(3,1,1) forecasts: Step 3 \\[\\hat{y}_{T+2|T} = (1+\\phi_1)\\hat{y}_{T+1|T} -(\\phi_1-\\phi_2)y_{T} - (\\phi_2-\\phi_3)y_{T-1}\\\\\\mbox{} -\\phi_3y_{T-2}.\\] 2.8.2 Prediction intervals 95% prediction interval \\[\\hat{y}_{T+h|T} \\pm 1.96\\sqrt{v_{T+h|T}}\\] where \\(v_{T+h|T}\\) is estimated forecast variance. \\(v_{T+1|T}=\\hat{\\sigma}^2\\) for all ARIMA models regardless of parameters and orders. Multi-step prediction intervals for \\(ARIMA(0,0,q)\\)): \\[y_t = \\varepsilon_t + \\sum_{i=1}^q \\theta_i \\varepsilon_{t-i}.\\] \\[\\hat{\\sigma}_h = \\hat{\\sigma}^2 \\left[ 1 + \\sum_{i=1}^{h-1} \\theta_i^2\\right], \\qquad\\text{for~} h=2,3,\\dots.\\] AR(1): Rewrite as MA(\\(\\infty\\)) and use above result. Other models beyond scope of this subject. Prediction intervals increase in size with forecast horizon. Prediction intervals can be difficult to calculate by hand Calculations assume residuals are uncorrelated and normally distributed. Prediction intervals tend to be too narrow. the uncertainty in the parameter estimates has not been accounted for. the ARIMA model assumes historical patterns will not change during the forecast period. the ARIMA model assumes uncorrelated future errors. 2.9 References: Brockwell, P. J., Brockwell, P. J., Davis, R. A., &amp; Davis, R. A. (2016). Introduction to time series and forecasting. springer. Hyndman, R. J., &amp; Athanasopoulos, G. (2018). Forecasting: principles and practice. OTexts. Zivot, E., &amp; Wang, J. (2006). Unit root tests. Modeling Financial Time Series with S-PLUS®, 111-139. References "],["exponential-smoothing.html", "Chapter 3 Exponential Smoothing 3.1 Introduction 3.2 Simple exponential smoothing 3.3 Models with trend 3.4 Models with seasonality 3.5 Innovations state space models 3.6 Forecasting with exponential smoothing 3.7 ARIMA vs ETS 3.8 References:", " Chapter 3 Exponential Smoothing 3.1 Introduction 3.1.1 Historical perspective Developed in the 1950s and 1960s as methods (algorithms) to produce point forecasts. Combine a “level”, “trend” (slope) and “seasonal” component to describe a time series. The rate of change of the components are controlled by “smoothing parameters”: \\(\\alpha\\), \\(\\beta\\) and \\(\\gamma\\) respectively. Need to choose best values for the smoothing parameters (and initial states). Equivalent ETS state space models developed in the 1990s and 2000s. 3.1.2 Big idea: control the rate of change \\(\\alpha\\) controls the flexibility of the level If \\(\\alpha = 0\\), the level never updates (mean) If \\(\\alpha = 1\\), the level updates completely (naive) \\(\\beta\\) controls the flexibility of the trend If \\(\\beta = 0\\), the trend is linear (regression trend) If \\(\\beta = 1\\), the trend updates every observation \\(\\gamma\\) controls the flexibility of the seasonality If \\(\\gamma = 0\\), the seasonality is fixed (seasonal means) If \\(\\gamma = 1\\), the seasonality updates completely (seasonal naive) 3.1.3 A model for levels, trends, and seasonalities We want a model that captures the level (\\(\\ell_t\\)), trend (\\(b_t\\)) and seasonality (\\(s_t\\)). How do we combine these elements? Additively? \\[y_t = \\ell_{t-1} + b_{t-1} + s_{t-m} + \\varepsilon_t\\] Multiplicatively? \\[y_t = \\ell_{t-1}b_{t-1}s_{t-m}(1 + \\varepsilon_t)\\] Perhaps a mix of both? \\[y_t = (\\ell_{t-1} + b_{t-1}) s_{t-m} + \\varepsilon_t\\] How do the level, trend and seasonal components evolve over time? General notation: \\[\\text{ETS: } \\textbf{E}\\text{xponen}\\textbf{T}\\text{ial}\\textbf{ S}\\text{moothing}\\] Error: Additive (\"A\") or multiplicative (\"M\") Trend: None (\"N\"), additive (\"A\"), multiplicative (\"M\"), or damped (\"Ad\" or \"Md\"). Seasonality: None (\"N\"), additive (\"A\") or multiplicative (\"M\") 3.2 Simple exponential smoothing Time series \\(y_1,y_2,\\dots,y_T\\). Random walk forecasts \\[\\hat{y}_{T+h|T} = y_T\\] Average forecasts \\[\\hat{y}_{T+h|T} = \\frac1T\\sum_{t=1}^T y_t\\] Want something in between these methods. Most recent data should have more weight. Forecast equation \\[\\hat{y}_{T+1|T} = \\alpha y_T + \\alpha(1-\\alpha) y_{T-1} + \\alpha(1-\\alpha)^2 y_{T-2}+ \\cdots\\] where \\(0 \\le \\alpha \\le1\\) Component form Forecast equation \\(\\hat{y}_{t+h|t} = \\ell_{t}\\) Smoothing equation \\(\\ell_{t} = \\alpha y_{t} + (1 - \\alpha)\\ell_{t-1}\\) \\(\\ell_t\\) is the level (or the smoothed value) of the series at time t. \\(\\hat{y}_{t+1|t} = \\alpha y_t + (1-\\alpha) \\hat{y}_{t|t-1}\\) Iterate to get exponentially weighted moving average form. Weighted average form \\[\\hat{y}_{T+1|T}=\\sum_{j=0}^{T-1} \\alpha(1-\\alpha)^j y_{T-j}+(1-\\alpha)^T \\ell_{0}\\] 3.2.1 Optimising smoothing parameters Need to choose best values for \\(\\alpha\\) and \\(\\ell_0\\). Similarly to regression, choose optimal parameters by minimising SSE: \\[\\text{SSE}=\\sum_{t=1}^T(y_t-\\hat{y}_{t|t-1})^2.\\] Unlike regression there is no closed form solution — use numerical optimization. For Algerian Exports example: \\(\\hat\\alpha = 0.8400\\) \\(\\hat\\ell_0 = 39.54\\) 3.2.2 Models and methods 3.2.2.1 Methods Algorithms that return point forecasts. 3.2.2.2 Models Generate same point forecasts but can also generate forecast distributions. A stochastic (or random) data generating process that can generate an entire forecast distribution. Allow for “proper” model selection. 3.2.3 ETS(A,N,N): A model for SES Component form Forecast equation: \\(\\hat{y}_{t+h|t} = \\ell_{t}\\) Smoothing equation: \\(\\ell_{t} = \\alpha y_{t} + (1 - \\alpha)\\ell_{t-1}\\) Forecast error: \\(e_t = y_t - \\hat{y}_{t|t-1} = y_t - \\ell_{t-1}\\) Error correction form \\[y_t = \\ell_{t-1} + e_t\\] \\[\\ell_{t}= \\ell_{t-1}+\\alpha( y_{t}-\\ell_{t-1})\\] \\(\\ell_{t}=\\ell_{t-1}+\\alpha e_{t}\\) Specify probability distribution for \\(e_t\\), we assume \\(e_t = \\varepsilon_t\\sim\\text{NID}(0,\\sigma^2)\\). 3.2.4 ETS(A,N,N) Measurement equation: \\(y_t = \\ell_{t-1} + \\varepsilon_t\\) State equation: \\(\\ell_t=\\ell_{t-1}+\\alpha \\varepsilon_t\\) where \\(\\varepsilon_t\\sim\\text{NID}(0,\\sigma^2)\\). “innovations” or “single source of error” because equations have the same error process, \\(\\varepsilon_t\\). Measurement equation: relationship between observations and states. State equation(s): evolution of the state(s) through time. 3.2.5 ETS(M,N,N) SES with multiplicative errors. Specify relative errors \\(\\varepsilon_t=\\frac{y_t-\\hat{y}_{t|t-1}}{\\hat{y}_{t|t-1}}\\sim \\text{NID}(0,\\sigma^2)\\) Substituting \\(\\hat{y}_{t|t-1}=\\ell_{t-1}\\) gives: \\(y_t = \\ell_{t-1}+\\ell_{t-1}\\varepsilon_t\\) \\(e_t = y_t - \\hat{y}_{t|t-1} = \\ell_{t-1}\\varepsilon_t\\) Measurement equation: \\(y_t = \\ell_{t-1}(1 + \\varepsilon_t)\\) State equation: \\(\\ell_t=\\ell_{t-1}(1+\\alpha \\varepsilon_t)\\) Models with additive and multiplicative errors with the same parameters generate the same point forecasts but different prediction intervals. 3.2.6 ETS(A,N,N): Specifying the model ETS(y ~ error(&quot;A&quot;) + trend(&quot;N&quot;) + season(&quot;N&quot;)) By default, an optimal value for \\(\\alpha\\) and \\(\\ell_0\\) is used. \\(\\alpha\\) can be chosen manually in trend(). trend(&quot;N&quot;, alpha = 0.5) trend(&quot;N&quot;, alpha_range = c(0.2, 0.8)) 3.2.7 Example: Algerian Exports algeria_economy &lt;- global_economy %&gt;% filter(Country == &quot;Algeria&quot;) fit &lt;- algeria_economy %&gt;% model(ANN = ETS(Exports ~ error(&quot;A&quot;) + trend(&quot;N&quot;) + season(&quot;N&quot;))) report(fit) ## Series: Exports ## Model: ETS(A,N,N) ## Smoothing parameters: ## alpha = 0.84 ## ## Initial states: ## l ## 39.54 ## ## sigma^2: 35.63 ## ## AIC AICc BIC ## 446.7 447.2 452.9 components(fit) %&gt;% autoplot() components(fit) %&gt;% left_join(fitted(fit), by = c(&quot;Country&quot;, &quot;.model&quot;, &quot;Year&quot;)) ## # A dable: 59 x 7 [1Y] ## # Key: Country, .model [1] ## # ETS(A,N,N) Decomposition: Exports = lag(level, 1) + ## # remainder ## Country .model Year Exports level remainder .fitted ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algeria ANN 1959 NA 39.5 NA NA ## 2 Algeria ANN 1960 39.0 39.1 -0.496 39.5 ## 3 Algeria ANN 1961 46.2 45.1 7.12 39.1 ## 4 Algeria ANN 1962 19.8 23.8 -25.3 45.1 ## 5 Algeria ANN 1963 24.7 24.6 0.841 23.8 ## 6 Algeria ANN 1964 25.1 25.0 0.534 24.6 ## 7 Algeria ANN 1965 22.6 23.0 -2.39 25.0 ## 8 Algeria ANN 1966 26.0 25.5 3.00 23.0 ## 9 Algeria ANN 1967 23.4 23.8 -2.07 25.5 ## 10 Algeria ANN 1968 23.1 23.2 -0.630 23.8 ## # … with 49 more rows fit %&gt;% forecast(h = 5) %&gt;% autoplot(algeria_economy) + ylab(&quot;Exports (% of GDP)&quot;) + xlab(&quot;Year&quot;) 3.3 Models with trend 3.3.1 Holt’s linear trend Component form Forecast \\(\\hat{y}_{t+h|t} = \\ell_{t} + hb_{t}\\) Level \\(\\ell_{t} = \\alpha y_{t} + (1 - \\alpha)(\\ell_{t-1} + b_{t-1})\\) Trend \\(b_{t} = \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 -\\beta^*)b_{t-1}\\) Two smoothing parameters \\(\\alpha\\) and \\(\\beta^*\\) (\\(0\\le\\alpha,\\beta^*\\le1\\)). \\(\\ell_t\\) level: weighted average between \\(y_t\\) and one-step ahead forecast for time \\(t\\), \\((\\ell_{t-1} + b_{t-1}=\\hat{y}_{t|t-1})\\) \\(b_t\\) slope: weighted average of \\((\\ell_{t} - \\ell_{t-1})\\) and \\(b_{t-1}\\), current and previous estimate of slope. Choose \\(\\alpha, \\beta^*, \\ell_0, b_0\\) to minimise SSE. 3.3.2 ETS(A,A,N) Holt’s linear method with additive errors. Assume \\(\\varepsilon_t=y_t-\\ell_{t-1}-b_{t-1} \\sim\\text{NID}(0,\\sigma^2)\\). Substituting into the error correction equations for Holt’s linear method \\[y_t=\\ell_{t-1}+b_{t-1}+\\varepsilon_t\\] \\[\\ell_t=\\ell_{t-1}+b_{t-1}+\\alpha \\varepsilon_t\\] \\[b_t=b_{t-1}+\\alpha\\beta^* \\varepsilon_t\\] For simplicity, set \\(\\beta=\\alpha \\beta^*\\). 3.3.3 Exponential smoothing: trend/slope 3.3.4 ETS(M,A,N) Holt’s linear method with multiplicative errors. Assume \\(\\varepsilon_t=\\frac{y_t-(\\ell_{t-1}+b_{t-1})}{(\\ell_{t-1}+b_{t-1})}\\) Following a similar approach as above, the innovations state space model underlying Holt’s linear method with multiplicative errors is specified as \\[y_t=(\\ell_{t-1}+b_{t-1})(1+\\varepsilon_t)\\] \\[\\ell_t=(\\ell_{t-1}+b_{t-1})(1+\\alpha \\varepsilon_t)\\] \\[b_t=b_{t-1}+\\beta(\\ell_{t-1}+b_{t-1}) \\varepsilon_t\\] where again \\(\\beta=\\alpha \\beta^*\\) and \\(\\varepsilon_t \\sim \\text{NID}(0,\\sigma^2)\\). 3.3.5 ETS(A,A,N): Specifying the model ETS(y ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;N&quot;)) By default, optimal values for \\(\\beta\\) and \\(b_0\\) are used. \\(\\beta\\) can be chosen manually in trend(). trend(&quot;A&quot;, beta = 0.004) trend(&quot;A&quot;, beta_range = c(0, 0.1)) 3.3.6 Example: Australian population aus_economy &lt;- global_economy %&gt;% filter(Code == &quot;AUS&quot;) %&gt;% mutate(Pop = Population/1e6) fit &lt;- aus_economy %&gt;% model(AAN = ETS(Pop ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;N&quot;))) report(fit) ## Series: Pop ## Model: ETS(A,A,N) ## Smoothing parameters: ## alpha = 0.9999 ## beta = 0.3266 ## ## Initial states: ## l b ## 10.05 0.2225 ## ## sigma^2: 0.0041 ## ## AIC AICc BIC ## -76.99 -75.83 -66.68 components(fit) %&gt;% autoplot() components(fit) %&gt;% left_join(fitted(fit), by = c(&quot;Country&quot;, &quot;.model&quot;, &quot;Year&quot;)) ## # A dable: 59 x 8 [1Y] ## # Key: Country, .model [1] ## # ETS(A,A,N) Decomposition: Pop = lag(level, 1) + ## # lag(slope, 1) + remainder ## Country .model Year Pop level slope remainder .fitted ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austral… AAN 1959 NA 10.1 0.222 NA NA ## 2 Austral… AAN 1960 10.3 10.3 0.222 -0.000145 10.3 ## 3 Austral… AAN 1961 10.5 10.5 0.217 -0.0159 10.5 ## 4 Austral… AAN 1962 10.7 10.7 0.231 0.0418 10.7 ## 5 Austral… AAN 1963 11.0 11.0 0.223 -0.0229 11.0 ## 6 Austral… AAN 1964 11.2 11.2 0.221 -0.00641 11.2 ## 7 Austral… AAN 1965 11.4 11.4 0.221 -0.000314 11.4 ## 8 Austral… AAN 1966 11.7 11.7 0.235 0.0418 11.6 ## 9 Austral… AAN 1967 11.8 11.8 0.206 -0.0869 11.9 ## 10 Austral… AAN 1968 12.0 12.0 0.208 0.00350 12.0 ## # … with 49 more rows fit %&gt;% forecast(h = 10) %&gt;% autoplot(aus_economy) + ylab(&quot;Population&quot;) + xlab(&quot;Year&quot;) 3.3.7 Damped trend method Component form \\[\\hat{y}_{t+h|t} = \\ell_{t} + (\\phi+\\phi^2 + \\dots + \\phi^{h})b_{t}\\] \\[\\ell_{t} = \\alpha y_{t} + (1 - \\alpha)(\\ell_{t-1} + \\phi b_{t-1})\\] \\[b_{t} = \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 -\\beta^*)\\phi b_{t-1}.\\] Damping parameter \\(0&lt;\\phi&lt;1\\). If \\(\\phi=1\\), identical to Holt’s linear trend. As \\(h\\rightarrow\\infty\\), \\(\\hat{y}_{T+h|T}\\rightarrow \\ell_T+\\phi b_T/(1-\\phi)\\). Short-run forecasts trended, long-run forecasts constant. 3.3.8 Example: Australian population Write down the model for ETS(A,\\(A_d\\),N) aus_economy %&gt;% model(holt = ETS(Pop ~ error(&quot;A&quot;) + trend(&quot;Ad&quot;) + season(&quot;N&quot;))) %&gt;% forecast(h = 20) %&gt;% autoplot(aus_economy) fit &lt;- aus_economy %&gt;% filter(Year &lt;= 2010) %&gt;% model( ses = ETS(Pop ~ error(&quot;A&quot;) + trend(&quot;N&quot;) + season(&quot;N&quot;)), holt = ETS(Pop ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;N&quot;)), damped = ETS(Pop ~ error(&quot;A&quot;) + trend(&quot;Ad&quot;) + season(&quot;N&quot;)) ) tidy(fit) accuracy(fit) term SES Linear trend Damped trend alpha 1.00 1.00 1.00 beta^* 0.30 0.40 phi 0.98 l_0 10.28 10.05 10.04 b_0 0.22 0.25 Training RMSE 0.24 0.06 0.07 Test RMSE 1.63 0.15 0.21 Test MASE 6.18 0.55 0.75 Test MAPE 6.09 0.55 0.74 Test MAE 1.45 0.13 0.18 3.4 Models with seasonality 3.4.1 Holt-Winters additive method Holt and Winters extended Holt’s method to capture seasonality. Component form \\[\\hat{y}_{t+h|t} = \\ell_{t} + hb _{t} + s_{t+h-m(k+1)}\\] \\[\\ell_{t} = \\alpha(y_{t} - s_{t-m}) + (1 - \\alpha)(\\ell_{t-1} + b_{t-1})\\] \\[b_{t} = \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 - \\beta^*)b_{t-1}\\] \\[s_{t} = \\gamma (y_{t}-\\ell_{t-1}-b_{t-1}) + (1-\\gamma)s_{t-m}\\] \\(k=\\) integer part of \\((h-1)/m\\). Ensures estimates from the final year are used for forecasting. Parameters: \\(0\\le \\alpha\\le 1\\), \\(0\\le \\beta^*\\le 1\\), \\(0\\le \\gamma\\le 1-\\alpha\\) and \\(m=\\) period of seasonality (e.g. \\(m=4\\) for quarterly data). Seasonal component is usually expressed as \\[s_{t} = \\gamma^* (y_{t}-\\ell_{t})+ (1-\\gamma^*)s_{t-m}.\\] Substitute in for \\(\\ell_t\\): \\[s_{t} = \\gamma^*(1-\\alpha) (y_{t}-\\ell_{t-1}-b_{t-1})+ [1-\\gamma^*(1-\\alpha)]s_{t-m}\\] We set \\(\\gamma=\\gamma^*(1-\\alpha)\\). The usual parameter restriction is \\(0\\le\\gamma^*\\le1\\), which translates to \\(0\\le\\gamma\\le(1-\\alpha)\\). 3.4.2 ETS(A,A,A) Holt-Winters additive method with additive errors. Forecast equation} \\(\\hat{y}_{t+h|t} = \\ell_{t} + hb_{t} + s_{t+h-m(k+1)}\\) Observation equation} \\(y_t=\\ell_{t-1}+b_{t-1}+s_{t-m} + \\varepsilon_t\\) State equations} \\[\\ell_t=\\ell_{t-1}+b_{t-1}+\\alpha \\varepsilon_t\\] \\[b_t=b_{t-1}+\\beta \\varepsilon_t\\] \\[s_t = s_{t-m} + \\gamma\\varepsilon_t\\] Forecast errors: \\(\\varepsilon_{t} = y_t - \\hat{y}_{t|t-1}\\) \\(k\\) is integer part of \\((h-1)/m\\) Activity Write down the model for ETS(A,N,A) 3.4.3 Holt-Winters multiplicative method For when seasonal variations are changing proportional to the level of the series. Component form \\[\\hat{y}{t+h}{t} = (\\ell_{t} + hb_{t})s_{t+h-m(k+1)}\\] \\[\\ell_{t} = \\alpha \\frac{y_{t}}{s_{t-m}} + (1 - \\alpha)(\\ell_{t-1} + b_{t-1})\\] b_{t} &amp;= \\[\\beta^*(\\ell_{t}-\\ell_{t-1}) + (1 - \\beta^*)b_{t-1}\\] \\[s_{t} = \\gamma \\frac{y_{t}}{(\\ell_{t-1} + b_{t-1})} + (1 - \\gamma)s_{t-m}\\] \\(k\\) is integer part of \\((h-1)/m\\). With additive method \\(s_t\\) is in absolute terms:within each year \\(\\sum_i s_i \\approx 0\\). With multiplicative method \\(s_t\\) is in relative terms:within each year \\(\\sum_i s_i \\approx m\\). 3.4.4 ETS(M,A,M) Holt-Winters multiplicative method with multiplicative errors. Forecast equation \\(\\hat{y}_{t+h|t} = (\\ell_{t} + hb_{t}) s_{t+h-m(k+1)}\\) Observation equation \\(y_t= (\\ell_{t-1}+b_{t-1})s_{t-m}(1 + \\varepsilon_t)\\) State equations \\[\\ell_t=(\\ell_{t-1}+b_{t-1})(1+\\alpha \\varepsilon_t)\\] \\[b_t=b_{t-1} +\\beta(\\ell_{t-1}+b_{t-1}) \\varepsilon_t\\] \\[s_t = s_{t-m}(1 + \\gamma\\varepsilon_t)\\] Forecast errors: \\(\\varepsilon_{t} = (y_t - \\hat{y}_{t|t-1})/\\hat{y}_{t|t-1}\\) \\(k\\) is integer part of \\((h-1)/m\\). 3.4.5 Example: Australian holiday tourism aus_holidays &lt;- tourism %&gt;% filter(Purpose == &quot;Holiday&quot;) %&gt;% summarise(Trips = sum(Trips)) fit &lt;- aus_holidays %&gt;% model( additive = ETS(Trips ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;A&quot;)), multiplicative = ETS(Trips ~ error(&quot;M&quot;) + trend(&quot;A&quot;) + season(&quot;M&quot;)) ) fc &lt;- fit %&gt;% forecast() Estimated components components(fit) ## # A dable: 168 x 7 [1Q] ## # Key: .model [2] ## # ETS(A,A,A) &amp; ETS(M,A,M) Decomposition: Trips = lag(level, ## # 1) + lag(slope, 1) + lag(season, 4) + remainder ## .model Quarter Trips level slope season remainder ## &lt;chr&gt; &lt;qtr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 additive 1997 Q1 NA NA NA 1512. NA ## 2 additive 1997 Q2 NA NA NA -290. NA ## 3 additive 1997 Q3 NA NA NA -684. NA ## 4 additive 1997 Q4 NA 9899. -37.4 -538. NA ## 5 additive 1998 Q1 11806. 9964. -24.5 1512. 433. ## 6 additive 1998 Q2 9276. 9851. -35.6 -290. -374. ## 7 additive 1998 Q3 8642. 9700. -50.2 -684. -489. ## 8 additive 1998 Q4 9300. 9694. -44.6 -538. 188. ## 9 additive 1999 Q1 11172. 9652. -44.3 1512. 10.7 ## 10 additive 1999 Q2 9608. 9676. -35.6 -290. 290. ## # … with 158 more rows 3.4.6 Holt-Winters damped method Often the single most accurate forecasting method for seasonal data: \\[\\hat{y}_{t+h|t} = [\\ell_{t} + (\\phi+\\phi^2 + \\dots + \\phi^{h})b_{t}]s_{t+h-m(k+1)}\\] \\[\\ell_{t} = \\alpha(y_{t} / s_{t-m}) + (1 - \\alpha)(\\ell_{t-1} + \\phi b_{t-1})\\] \\[b_{t} = \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 - \\beta^*)\\phi b_{t-1}\\] \\[s_{t} = \\gamma \\frac{y_{t}}{(\\ell_{t-1} + \\phi b_{t-1})} + (1 - \\gamma)s_{t-m}\\] 3.5 Innovations state space models 3.5.1 Exponential smoothing methods \\((N,N)\\): Simple exponential smoothing \\((A,N)\\): Holt’s linear method \\((A_d,N)\\): Additive damped trend method \\((A,A)\\): Additive Holt-Winters’ method \\((A,M)\\): Multiplicative Holt-Winters’ method \\((A_d,M)\\): Damped multiplicative Holt-Winters’ method There are also multiplicative trend methods (not recommended). 3.5.2 ETS models Additive Error Multiplicative Error 3.5.3 Additive error models 3.5.4 Multiplicative error models 3.5.5 Estimating ETS models Smoothing parameters \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) and \\(\\phi\\), and the initial states \\(\\ell_0\\), \\(b_0\\), \\(s_0,s_{-1},\\dots,s_{-m+1}\\) are estimated by maximising the “likelihood” = the probability of the data arising from the specified model. For models with additive errors equivalent to minimising SSE. For models with multiplicative errors, not equivalent to minimising SSE. 3.5.6 Innovations state space models Let \\(\\mathbf{x}_t = (\\ell_t, b_t, s_t, s_{t-1}, \\dots, s_{t-m+1})\\) and \\(\\varepsilon_t\\stackrel{\\mbox{\\scriptsize iid}}{\\sim} \\mbox{N}(0,\\sigma^2)\\). Additive errors \\[k(x)=1. \\qquad y_t = \\mu_{t} + \\varepsilon_t.\\] Multiplicative errors \\[k(\\mathbf{x}_{t-1}) = \\mu_{t}.\\qquad y_t = \\mu_{t}(1 + \\varepsilon_t).\\] \\[\\varepsilon_t = (y_t - \\mu_t)/\\mu_t \\text{ is relative error}.\\] 3.5.7 Innovations state space models Estimation \\[L^*(\\mathbf\\theta,\\mathbf{x}_0) = T\\log\\!\\bigg(\\sum_{t=1}^T \\varepsilon^2_t\\!\\bigg) + 2\\sum_{t=1}^T \\log|k(\\mathbf{x}_{t-1})|\\] \\[= -2\\log(\\text{Likelihood}) + \\mbox{constant}\\] Estimate parameters \\(\\mathbf\\theta = (\\alpha,\\beta,\\gamma,\\phi)\\) and initial states \\(\\mathbf{x}_0 = (\\ell_0,b_0,s_0,s_{-1},\\dots,s_{-m+1})\\) by minimizing \\(L^*\\). 3.5.8 Parameter restrictions 3.5.8.1 Usual region Traditional restrictions in the methods \\(0&lt; \\alpha,\\beta^*,\\gamma^*,\\phi&lt;1\\)(equations interpreted as weighted averages). In models we set \\(\\beta=\\alpha\\beta^*\\) and \\(\\gamma=(1-\\alpha)\\gamma^*\\). Therefore \\(0&lt; \\alpha &lt;1\\), \\(0 &lt; \\beta &lt; \\alpha\\) and \\(0&lt; \\gamma &lt; 1-\\alpha\\). \\(0.8&lt;\\phi&lt;0.98\\) — to prevent numerical difficulties. 3.5.8.2 Admissible region To prevent observations in the distant past having a continuing effect on current forecasts. Usually (but not always) less restrictive than thetraditional region. For example for ETS(A,N,N): \\(0&lt; \\alpha &lt;1\\) — is \\(0&lt; \\alpha &lt;2\\). 3.5.9 Model selection Akaike’s Information Criterion \\[\\text{AIC} = -2\\log(\\text{L}) + 2k\\] where \\(L\\) is the likelihood and \\(k\\) is the number of parameters initial states estimated in the model. Corrected AIC \\[\\text{AIC}_{\\text{c}} = \\text{AIC} + \\frac{2(k+1)(k+2)}{T-k}\\] which is the AIC corrected (for small sample bias). Bayesian Information Criterion \\[\\text{BIC} = \\text{AIC} + k(\\log(T)-2).\\] 3.5.10 AIC and cross-validation Minimizing the AIC assuming Gaussian residuals is asymptotically equivalent to minimizing one-step time series cross validation MSE. 3.5.11 Automatic forecasting From Hyndman et al. (IJF, 2002): Apply each model that is appropriate to the data. Optimize parameters and initial values using MLE (or some other criterion). Select best method using AICc: Produce forecasts using best method. Obtain forecast intervals using underlying state space model. Method performed very well in M3 competition. 3.5.12 Example: National populations fit &lt;- global_economy %&gt;% mutate(Pop = Population / 1e6) %&gt;% model(ets = ETS(Pop)) fit ## # A mable: 263 x 2 ## # Key: Country [263] ## Country ets ## &lt;fct&gt; &lt;model&gt; ## 1 Afghanistan &lt;ETS(A,A,N)&gt; ## 2 Albania &lt;ETS(M,A,N)&gt; ## 3 Algeria &lt;ETS(M,A,N)&gt; ## 4 American Samoa &lt;ETS(M,A,N)&gt; ## 5 Andorra &lt;ETS(M,A,N)&gt; ## 6 Angola &lt;ETS(M,A,N)&gt; ## 7 Antigua and Barbuda &lt;ETS(M,A,N)&gt; ## 8 Arab World &lt;ETS(M,A,N)&gt; ## 9 Argentina &lt;ETS(A,A,N)&gt; ## 10 Armenia &lt;ETS(M,A,N)&gt; ## # … with 253 more rows fit %&gt;% forecast(h = 5) ## # A fable: 1,315 x 5 [1Y] ## # Key: Country, .model [263] ## Country .model Year Pop .mean ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dist&gt; &lt;dbl&gt; ## 1 Afghanistan ets 2018 N(36, 0.012) 36.4 ## 2 Afghanistan ets 2019 N(37, 0.059) 37.3 ## 3 Afghanistan ets 2020 N(38, 0.16) 38.2 ## 4 Afghanistan ets 2021 N(39, 0.35) 39.0 ## 5 Afghanistan ets 2022 N(40, 0.64) 39.9 ## 6 Albania ets 2018 N(2.9, 0.00012) 2.87 ## 7 Albania ets 2019 N(2.9, 6e-04) 2.87 ## 8 Albania ets 2020 N(2.9, 0.0017) 2.87 ## 9 Albania ets 2021 N(2.9, 0.0036) 2.86 ## 10 Albania ets 2022 N(2.9, 0.0066) 2.86 ## # … with 1,305 more rows 3.5.13 Example: Australian holiday tourism holidays &lt;- tourism %&gt;% filter(Purpose == &quot;Holiday&quot;) fit &lt;- holidays %&gt;% model(ets = ETS(Trips)) fit ## # A mable: 76 x 4 ## # Key: Region, State, Purpose [76] ## Region State Purpose ets ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;model&gt; ## 1 Adelaide South Austral… Holiday &lt;ETS(A,N,A)&gt; ## 2 Adelaide Hills South Austral… Holiday &lt;ETS(A,A,N)&gt; ## 3 Alice Springs Northern Terr… Holiday &lt;ETS(M,N,A)&gt; ## 4 Australia&#39;s Coral Co… Western Austr… Holiday &lt;ETS(M,N,A)&gt; ## 5 Australia&#39;s Golden O… Western Austr… Holiday &lt;ETS(M,N,M)&gt; ## 6 Australia&#39;s North We… Western Austr… Holiday &lt;ETS(A,N,A)&gt; ## 7 Australia&#39;s South We… Western Austr… Holiday &lt;ETS(M,N,M)&gt; ## 8 Ballarat Victoria Holiday &lt;ETS(M,N,A)&gt; ## 9 Barkly Northern Terr… Holiday &lt;ETS(A,N,A)&gt; ## 10 Barossa South Austral… Holiday &lt;ETS(A,N,N)&gt; ## # … with 66 more rows ## Series: Trips ## Model: ETS(M,N,A) ## Smoothing parameters: ## alpha = 0.1571 ## gamma = 0.0001001 ## ## Initial states: ## l s1 s2 s3 s4 ## 141.7 -60.96 130.9 -42.24 -27.66 ## ## sigma^2: 0.0388 ## ## AIC AICc BIC ## 852.0 853.6 868.7 ## # A dable: 84 x 9 [1Q] ## # Key: Region, State, Purpose, .model ## # [1] ## # ETS(M,N,A) Decomposition: Trips = (lag(level, 1) + ## # lag(season, 4)) * (1 + remainder) ## Region State Purpose .model Quarter Trips level season ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;qtr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Snowy… New … Holiday ets 1997 Q1 NA NA -27.7 ## 2 Snowy… New … Holiday ets 1997 Q2 NA NA -42.2 ## 3 Snowy… New … Holiday ets 1997 Q3 NA NA 131. ## 4 Snowy… New … Holiday ets 1997 Q4 NA 142. -61.0 ## 5 Snowy… New … Holiday ets 1998 Q1 101. 140. -27.7 ## 6 Snowy… New … Holiday ets 1998 Q2 112. 142. -42.2 ## 7 Snowy… New … Holiday ets 1998 Q3 310. 148. 131. ## 8 Snowy… New … Holiday ets 1998 Q4 89.8 148. -61.0 ## 9 Snowy… New … Holiday ets 1999 Q1 112. 147. -27.7 ## 10 Snowy… New … Holiday ets 1999 Q2 103. 147. -42.2 ## # … with 74 more rows, and 1 more variable: remainder &lt;dbl&gt; ## # A fable: 608 x 7 [1Q] ## # Key: Region, State, Purpose, .model [76] ## Region State Purpose .model Quarter Trips .mean ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;qtr&gt; &lt;dist&gt; &lt;dbl&gt; ## 1 Adelaide South … Holiday ets 2018 Q1 N(210, 457) 210. ## 2 Adelaide South … Holiday ets 2018 Q2 N(173, 473) 173. ## 3 Adelaide South … Holiday ets 2018 Q3 N(169, 489) 169. ## 4 Adelaide South … Holiday ets 2018 Q4 N(186, 505) 186. ## 5 Adelaide South … Holiday ets 2019 Q1 N(210, 521) 210. ## 6 Adelaide South … Holiday ets 2019 Q2 N(173, 537) 173. ## 7 Adelaide South … Holiday ets 2019 Q3 N(169, 553) 169. ## 8 Adelaide South … Holiday ets 2019 Q4 N(186, 569) 186. ## 9 Adelaid… South … Holiday ets 2018 Q1 N(19, 36) 19.4 ## 10 Adelaid… South … Holiday ets 2018 Q2 N(20, 36) 19.6 ## # … with 598 more rows 3.5.14 Some unstable models Some of the combinations of (Error, Trend, Seasonal) can lead to numerical difficulties; see equations with division by a state. These are: ETS(A,N,M), ETS(A,A,M), ETS(A,\\(A_d\\),M). Models with multiplicative errors are useful for strictly positive data, but are not numerically stable with data containing zeros or negative values. In that case only the six fully additive models will be applied. 3.5.15 Exponential smoothing models Additive Error Multiplicative Error 3.5.16 Residuals Response residuals \\[\\hat{e}_t = y_t - \\hat{y}_{t|t-1}\\] Innovation residuals Additive error model: \\[\\hat\\varepsilon_t = y_t - \\hat{y}_{t|t-1}\\] Multiplicative error model: \\[\\hat\\varepsilon_t = \\frac{y_t - \\hat{y}_{t|t-1}}{\\hat{y}_{t|t-1}}\\] 3.5.17 Example: Australian holiday tourism aus_holidays &lt;- tourism %&gt;% filter(Purpose == &quot;Holiday&quot;) %&gt;% summarise(Trips = sum(Trips)) fit &lt;- aus_holidays %&gt;% model(ets = ETS(Trips)) %&gt;% report() ## Series: Trips ## Model: ETS(M,N,M) ## Smoothing parameters: ## alpha = 0.3578 ## gamma = 0.0009686 ## ## Initial states: ## l s1 s2 s3 s4 ## 9667 0.943 0.9268 0.9684 1.162 ## ## sigma^2: 0.0022 ## ## AIC AICc BIC ## 1331 1333 1348 residuals(fit) residuals(fit, type = &quot;response&quot;) 3.6 Forecasting with exponential smoothing 3.6.1 Forecasting with ETS models Point forecasts: iterate the equations for \\(t=T+1,T+2,\\dots,T+h\\) and set all \\(\\varepsilon_t=0\\) for \\(t&gt;T\\). Not the same as \\(\\text{E}(y_{t+h} | \\mathbf{x}_t)\\) unless trend and seasonality are both additive. Point forecasts for ETS(A,,) are identical to ETS(M,,) if the parameters are the same. 3.6.2 Example: ETS(A,A,N) \\[y_{T+1} = \\ell_T + b_T + \\varepsilon_{T+1}\\] \\[\\hat{y}_{T+1|T} = \\ell_{T}+b_{T}\\] \\[y_{T+2} = \\ell_{T+1} + b_{T+1} + \\varepsilon_{T+2}\\] \\[= (\\ell_T + b_T + \\alpha\\varepsilon_{T+1}) + (b_T + \\beta \\varepsilon_{T+1}) + \\varepsilon_{T+2}\\] \\[\\hat{y}_{T+2|T} = \\ell_{T}+2b_{T}\\] etc. 3.6.3 Example: ETS(M,A,N) \\[y_{T+1} = (\\ell_T + b_T )(1+ \\varepsilon_{T+1})\\] \\[\\hat{y}_{T+1|T} = \\ell_{T}+b_{T}.\\] \\[y_{T+2} = (\\ell_{T+1} + b_{T+1})(1 + \\varepsilon_{T+2})\\] \\[= \\left\\{ (\\ell_T + b_T) (1+ \\alpha\\varepsilon_{T+1}) + \\left[b_T + \\beta (\\ell_T + b_T)\\varepsilon_{T+1}\\right] \\right\\} (1 + \\varepsilon_{T+2})\\] \\[\\hat{y}_{T+2|T} = \\ell_{T}+2b_{T}\\] etc. 3.6.4 Forecasting with ETS models Prediction intervals: can only generated using the models. The prediction intervals will differ between models with additive and multiplicative errors. Exact formulae for some models. More general to simulate future sample paths, conditional on the last estimate of the states, and to obtain prediction intervals from the percentiles of these simulated future paths. 3.6.5 Prediction intervals PI for most ETS models: \\(\\hat{y}_{T+h|T} \\pm c \\sigma_h\\), where \\(c\\) depends on coverage probability and \\(\\sigma_h\\) is forecast standard deviation. 3.6.6 Example: Corticosteroid drug sales h02 &lt;- PBS %&gt;% filter(ATC2 == &quot;H02&quot;) %&gt;% summarise(Cost = sum(Cost)) h02 %&gt;% autoplot(Cost) h02 %&gt;% model(ETS(Cost)) %&gt;% report() ## Series: Cost ## Model: ETS(M,Ad,M) ## Smoothing parameters: ## alpha = 0.3071 ## beta = 0.0001007 ## gamma = 0.0001007 ## phi = 0.9775 ## ## Initial states: ## l b s1 s2 s3 s4 s5 s6 s7 ## 417269 8206 0.8717 0.826 0.7563 0.7733 0.6872 1.284 1.325 ## s8 s9 s10 s11 s12 ## 1.18 1.164 1.105 1.048 0.9806 ## ## sigma^2: 0.0046 ## ## AIC AICc BIC ## 5515 5519 5575 h02 %&gt;% model(ETS(Cost ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;A&quot;))) %&gt;% report() ## Series: Cost ## Model: ETS(A,A,A) ## Smoothing parameters: ## alpha = 0.1702 ## beta = 0.006311 ## gamma = 0.4546 ## ## Initial states: ## l b s1 s2 s3 s4 s5 s6 ## 409706 9097 -99075 -136602 -191496 -174531 -241437 210644 ## s7 s8 s9 s10 s11 s12 ## 244644 145368 130570 84458 39132 -11674 ## ## sigma^2: 3.499e+09 ## ## AIC AICc BIC ## 5585 5589 5642 h02 %&gt;% model(ETS(Cost)) %&gt;% forecast() %&gt;% autoplot(h02) h02 %&gt;% model( auto = ETS(Cost), AAA = ETS(Cost ~ error(&quot;A&quot;) + trend(&quot;A&quot;) + season(&quot;A&quot;)) ) %&gt;% accuracy() Model ME MAE RMSE MAPE MASE auto 2461 38649 51102 4.989 0.6376 AAA -5780 43378 56784 6.048 0.7156 3.7 ARIMA vs ETS Myth that ARIMA models are more general than exponential smoothing. Linear exponential smoothing models all special cases of ARIMA models. Non-linear exponential smoothing models have no equivalent ARIMA counterparts. Many ARIMA models have no exponential smoothing counterparts. ETS models all non-stationary. Models with seasonality or non-damped trend (or both) have two unit roots; all other models have one unit 3.7.1 Equivalences ETS model ARIMA model Parameters ETS(A,N,N) ARIMA(0,1,1) \\(\\theta_1 = \\alpha-1\\) ETS(A,A,N) ARIMA(0,2,2) \\(\\theta_1 = \\alpha+\\beta-2\\) \\(\\theta_2 = 1-\\alpha\\) ETS(A,\\(A_d\\),N) ARIMA(1,1,2) \\(\\phi_1=\\phi\\) \\(\\theta_1 = \\alpha+\\phi\\beta-1-\\phi\\) \\(\\theta_2 = (1-\\alpha)\\phi\\) ETS(A,N,A) ARIMA(0,0,\\(m\\))(0,1,0)\\(_m\\) ETS(A,A,A) ARIMA(0,1,\\(m+1\\))(0,1,0)\\(_m\\) ETS(A,\\(A_d\\),A) ARIMA(1,0,\\(m+1\\))(0,1,0)\\(_m\\) 3.8 References: Hyndman, R. J., &amp; Athanasopoulos, G. (2018). Forecasting: principles and practice. OTexts. "],["references-2.html", "References", " References "]]
